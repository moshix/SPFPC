
                            SPF/PC Version 4.0
                       CTC REXX Language Reference
                           Online Documentation
             (C) Copyright Command Technology Corporation 1994

      You can use this online documentation in the following ways:

      *  Print it on an HP LaserJet or other ASCII text printer.  Three
         hole punch and bind for reference purposes. This document is
         approximately 240 pages (8.5" x 11.0"). It assumes a 10 pitch
         monospace font.

      *  Use SPF/PC to browse this documentation directly. Peruse the
         Table of Contents. Find the desired text using the primary
         command "find" in the following form:

             find [nnn]

         where "nnn" is the desired page number.

      The Table of Contents follows.




                            Table of Contents




   Introduction   . . . . . . . . . . . . . . . . . . . . . . . . . . 2
     How To Use This Manual   . . . . . . . . . . . . . . . . . . . . 2
     Where to Start   . . . . . . . . . . . . . . . . . . . . . . . . 3
     How to Read the Syntax Diagrams  . . . . . . . . . . . . . . . . 3

   Using REXX   . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
     Limits   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
     Comparison of Built-In Functions   . . . . . . . . . . . . . . . 6
     Differences from CMS REXX  . . . . . . . . . . . . . . . . . . . 8

   Language Definition  . . . . . . . . . . . . . . . . . . . . . . . 9
     Clauses  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
     Tokens   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
       Comments   . . . . . . . . . . . . . . . . . . . . . . . . . . 9
       Literal strings  . . . . . . . . . . . . . . . . . . . . . .  10
       Hexadecimal strings  . . . . . . . . . . . . . . . . . . . .  10
       Binary strings   . . . . . . . . . . . . . . . . . . . . . .  11
       Symbols  . . . . . . . . . . . . . . . . . . . . . . . . . .  11
       Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . .  11
       Operators and special characters   . . . . . . . . . . . . .  12
       Implied semicolons   . . . . . . . . . . . . . . . . . . . .  13
     Program Execution  . . . . . . . . . . . . . . . . . . . . . .  13

   Clauses  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14

   Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . .  16
     Operators and Terms  . . . . . . . . . . . . . . . . . . . . .  16
       Terms  . . . . . . . . . . . . . . . . . . . . . . . . . . .  16
       Operators  . . . . . . . . . . . . . . . . . . . . . . . . .  16
       Parentheses and operator precedence  . . . . . . . . . . . .  19

   Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
     Symbols  . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
       Selecting a name for a variable  . . . . . . . . . . . . . .  21
       Initial values   . . . . . . . . . . . . . . . . . . . . . .  22
     Types of Symbols   . . . . . . . . . . . . . . . . . . . . . .  22
       Constant symbols   . . . . . . . . . . . . . . . . . . . . .  22
       Simple symbols   . . . . . . . . . . . . . . . . . . . . . .  22
       Compound symbols   . . . . . . . . . . . . . . . . . . . . .  23
       How REXX processes compound symbols  . . . . . . . . . . . .  23
       Using compound symbols as arrays   . . . . . . . . . . . . .  24
       When to use quotes   . . . . . . . . . . . . . . . . . . . .  24
     Special Variables  . . . . . . . . . . . . . . . . . . . . . .  26

   System Commands  . . . . . . . . . . . . . . . . . . . . . . . .  27

   Keyword Instructions   . . . . . . . . . . . . . . . . . . . . .  28
     ADDRESS  . . . . . . . . . . . . . . . . . . . . . . . . . . .  29
     ARG  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  31
     CALL   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33
     DO   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37
       Simple DO group  . . . . . . . . . . . . . . . . . . . . . .  38
       Simple repetitive loop   . . . . . . . . . . . . . . . . . .  39
       Controlled repetitive loop   . . . . . . . . . . . . . . . .  39
       Conditional loop   . . . . . . . . . . . . . . . . . . . . .  41
     DROP   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  42
     EXIT   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43
     IF   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  44
     INTERPRET  . . . . . . . . . . . . . . . . . . . . . . . . . .  46
     ITERATE  . . . . . . . . . . . . . . . . . . . . . . . . . . .  48
     LEAVE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  49
     NOP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  51
     NUMERIC  . . . . . . . . . . . . . . . . . . . . . . . . . . .  52
     OPTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . .  54
     PARSE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  55
     PROCEDURE  . . . . . . . . . . . . . . . . . . . . . . . . . .  59
     PULL   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  61
     PUSH   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  62
     QUEUE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63
     RETURN   . . . . . . . . . . . . . . . . . . . . . . . . . . .  64
     SAY  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  65
     SELECT   . . . . . . . . . . . . . . . . . . . . . . . . . . .  66
     SIGNAL   . . . . . . . . . . . . . . . . . . . . . . . . . . .  68
     TRACE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  71
       Interactive tracing  . . . . . . . . . . . . . . . . . . . .  73
       The format of TRACE output   . . . . . . . . . . . . . . . .  73

   Functions  . . . . . . . . . . . . . . . . . . . . . . . . . . .  75
     Types of Functions   . . . . . . . . . . . . . . . . . . . . .  75
       Search order   . . . . . . . . . . . . . . . . . . . . . . .  76
       Error recovery   . . . . . . . . . . . . . . . . . . . . . .  76
     Built-In Functions   . . . . . . . . . . . . . . . . . . . . .  77
     Word Functions   . . . . . . . . . . . . . . . . . . . . . . .  80
     String Functions   . . . . . . . . . . . . . . . . . . . . . .  81
     Conversion Functions   . . . . . . . . . . . . . . . . . . . .  82
     Math Functions   . . . . . . . . . . . . . . . . . . . . . . .  82
     I/O Functions  . . . . . . . . . . . . . . . . . . . . . . . .  83
     Information Functions  . . . . . . . . . . . . . . . . . . . .  83
     ABBREV   . . . . . . . . . . . . . . . . . . . . . . . . . . .  85
     ABS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
     ADDRESS  . . . . . . . . . . . . . . . . . . . . . . . . . . .  88
     ARG  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  89
     BITAND   . . . . . . . . . . . . . . . . . . . . . . . . . . .  91
     BITOR  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  92
     BITXOR   . . . . . . . . . . . . . . . . . . . . . . . . . . .  93
     B2X  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94
     CENTER   . . . . . . . . . . . . . . . . . . . . . . . . . . .  95
     CHARIN   . . . . . . . . . . . . . . . . . . . . . . . . . . .  96
     CHAROUT  . . . . . . . . . . . . . . . . . . . . . . . . . . .  98
     CHARS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
     COMPARE  . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
     CONDITION  . . . . . . . . . . . . . . . . . . . . . . . . . . 102

     COPIES   . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
     C2D  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
     C2X  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
     DATATYPE   . . . . . . . . . . . . . . . . . . . . . . . . . . 108
     DATE   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
     DELSTR   . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
     DELWORD  . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
     DIGITS   . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
     D2C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
     D2X  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
     ERRORTEXT  . . . . . . . . . . . . . . . . . . . . . . . . . . 119
     FORM   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
     FORMAT   . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
     FUZZ   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
     INSERT   . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
     LASTPOS  . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
     LEFT   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
     LENGTH   . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
     LINEIN   . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
     LINEOUT  . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
     LINES  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
     MAX  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
     MIN  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
     OVERLAY  . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
     POS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137
     QUEUED   . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
     RANDOM   . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
     REVERSE  . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
     RIGHT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 142
     SIGN   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
     SOURCELINE   . . . . . . . . . . . . . . . . . . . . . . . . . 144
     SPACE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
     STREAM   . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
     STRIP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
     SUBSTR   . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
     SUBWORD  . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
     SYMBOL   . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
     TIME   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
     TRACE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
     TRANSLATE  . . . . . . . . . . . . . . . . . . . . . . . . . . 158
     TRUNC  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
     VALUE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
     VERIFY   . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
     WORD   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
     WORDINDEX  . . . . . . . . . . . . . . . . . . . . . . . . . . 166
     WORDLENGTH   . . . . . . . . . . . . . . . . . . . . . . . . . 167
     WORDPOS  . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
     WORDS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
     XRANGE   . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
     X2B  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
     X2C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
     X2D  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173

   Parsing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
     Parsing With Words   . . . . . . . . . . . . . . . . . . . . . 175
     Parsing With Patterns  . . . . . . . . . . . . . . . . . . . . 176
       Parsing with literal patterns  . . . . . . . . . . . . . . . 176
       Parsing with variable patterns   . . . . . . . . . . . . . . 178

       Parsing with numeric patterns  . . . . . . . . . . . . . . . 179
       Parsing with positional patterns   . . . . . . . . . . . . . 180
       Parsing with relative patterns   . . . . . . . . . . . . . . 180
     Parsing More Than One String   . . . . . . . . . . . . . . . . 182

   Numerics and Math  . . . . . . . . . . . . . . . . . . . . . . . 183
     Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
       Precision  . . . . . . . . . . . . . . . . . . . . . . . . . 184
     Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . 184
     Arithmetic combination rules   . . . . . . . . . . . . . . . . 185
       Addition and subtraction   . . . . . . . . . . . . . . . . . 185
       Multiplication   . . . . . . . . . . . . . . . . . . . . . . 185
       Division   . . . . . . . . . . . . . . . . . . . . . . . . . 186
       Additional operators   . . . . . . . . . . . . . . . . . . . 186
     Comparing Numbers  . . . . . . . . . . . . . . . . . . . . . . 187
     Exponential notation   . . . . . . . . . . . . . . . . . . . . 188
       Use of numbers by REXX   . . . . . . . . . . . . . . . . . . 190
       Errors   . . . . . . . . . . . . . . . . . . . . . . . . . . 190

   Input and Output   . . . . . . . . . . . . . . . . . . . . . . . 191
     Manipulating character streams   . . . . . . . . . . . . . . . 192
       Manipulating input streams   . . . . . . . . . . . . . . . . 192
       Manipulating output streams  . . . . . . . . . . . . . . . . 192
       Manipulating the external data queue   . . . . . . . . . . . 193
     Input/Output Examples  . . . . . . . . . . . . . . . . . . . . 194

   Condition Traps  . . . . . . . . . . . . . . . . . . . . . . . . 197
     What Happens When a Condition is Trapped   . . . . . . . . . . 198
     Condition Information  . . . . . . . . . . . . . . . . . . . . 200
       Error and line number information  . . . . . . . . . . . . . 201
     Condition Trap Example   . . . . . . . . . . . . . . . . . . . 201

   Messages   . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
     Extended Return Codes  . . . . . . . . . . . . . . . . . . . . 209

   Sample Procedures  . . . . . . . . . . . . . . . . . . . . . . . 211




                              List of Tables




   Table 1. REXX Maximum Lengths  . . . . . . . . . . . . . . . . . . 6

   Table 2. REXX Maximum Numbers  . . . . . . . . . . . . . . . . . . 6

   Table 3. Comparison of Built-in Functions  . . . . . . . . . . . . 8

   Table 4. Concatenation Operators   . . . . . . . . . . . . . . .  17

   Table 5. Arithmetic Operators  . . . . . . . . . . . . . . . . .  17

   Table 6. Normal Comparative Operators  . . . . . . . . . . . . .  18

   Table 8. Logical Operators   . . . . . . . . . . . . . . . . . .  19

   Table 9. Operator Precedence   . . . . . . . . . . . . . . . . .  19

   Table 10. Built-in Functions   . . . . . . . . . . . . . . . . .  80

   Table 11. Word Functions   . . . . . . . . . . . . . . . . . . .  81

   Table 12. String Functions   . . . . . . . . . . . . . . . . . .  82

   Table 13. Conversion Functions   . . . . . . . . . . . . . . . .  82

   Table 14. Math Functions   . . . . . . . . . . . . . . . . . . .  83

   Table 15. I/O Functions  . . . . . . . . . . . . . . . . . . . .  83

   Table 16. Information Functions  . . . . . . . . . . . . . . . .  84




                                Chapter 1.
                               Introduction




      CTC REXX is a proper subset of IBM SAA language REXX which is
      hosted on MVS/TSO, VM/CMS, and OS/2 platforms.  CTC REXX does not
      support non-SAA compliant instructions or functions nor any
      extensions which would render CTC REXX non-portable.

      This manual explains how to use CTC REXX in the context of a
      macro language extension to SPF/PC. While powerful and flexible,
      CTC REXX is not intended to be a full blown programming language.

      Third party implementations with extensions to the core language
      are available for DOS, OS/2, UNIX and other operating system
      environments.

      The original specification for the REXX language can be found in
      the book The REXX Language: A Practical Approach to Programming
      by M.F. Cowlishaw (Prentice-Hall, 1985), ISBN 0-13-780735-X-01.
      The REXX Language provides a complete reference of the REXX
      language, the philosophy which shaped the language, and a histor-
      ical perspective of the language.

      A general introduction and tutorial for the REXX language can be
      found in the book Modern Programming Using REXX by R.P. O'Hara
      and D.G. Gomberg (Prentice-Hall, 1985).  Modern Programming Using
      REXX also provides an overview of programming and programming
      concepts. It is recommended both for programmers and
      non-programmers alike.

      A description of the REXX language, as implemented on the IBM
      VM/SP CMS operating system, can be found in the IBM publication
      VM/SP System Product Interpreter Reference, SC24-5239.  It is a
      reference manual recommended for experienced programmers.  An
      introduction and tutorial to the REXX language can be found in
      the IBM publication VM/SP System Product Interpreter User's
      Guide, SC24-5238.


   How To Use This Manual

      REXX contains a powerful set of control constructs, allowing a
      great degree of control, while remaining uncomplicated.  These
      constructs are implemented as REXX instructions.  A detailed
      description of each instruction is included in the section titled
      "Keyword Instructions" on page 28.

      REXX provides numerous built-in functions which perform a wide
      range of operations and types of operations (string, word, arith-


                                 Page [2]

      metic, etc.).  The built-in functions are listed in tabular form,
      both alphabetically on page 77 and alphabetically by type of
      operation on page 80.  A detailed description of each built-in
      function is included in the section titled "Built-In Functions"
      on page 77.  Cross-referencing of related functions is included
      with each built-in function description.


   Where to Start

      *  If you are familiar with the REXX language, the included REXX
         Reference Summary may be the only documentation required.
         However, we suggest that you take a few moments to review the
         sections titled "Keyword Instructions", "Built-In Functions",
         and "Condition Traps" to reveal some of the recent enhance-
         ments to the language.

      *  If you are not familiar with the REXX language, but are
         familiar with programming in other languages, we suggest that
         you review the sections titled "Language Definition", "Keyword
         Instructions", and "Built-In Functions".  We also suggest that
         the sample programs contained in "Appendix B. Sample Proce-
         dures" on page 211 be reviewed.

      *  If you are not familiar with the REXX language, but are
         familiar with the system batch language, we recommend that you
         review the sample programs contained in "Appendix B. Sample
         Procedures" on page 211.  These examples will give you a
         general "feel" for the language in a context similar to the
         way you used the system batch language.  The programs
         contained in "Appendix B. Sample Procedures" on page 211
         provide examples of REXX programs which are out of the scope
         of the system batch language, but well within the scope of
         REXX. In addition, we suggest that you review the sections
         titled "Language Definition", "Keyword Instructions", and
         "Built-In Functions" in conjunction with reviewing the sample
         programs.  This will give you an example of the "rules" of the
         language while you are reading the "rules".


   How to Read the Syntax Diagrams

      In this book, the syntax of REXX commands and functions is illus-
      trated by the diagramming scheme described below.

      Syntax diagrams are read from left to right and top to bottom.
      Every syntax diagram begins a double right-arrow sequence
      (ÄÄ  ) and ends with with a right-arrow/left-arrow sequence
      (ÄÄ  ).

      Keywords are indicated by upper-case text.  They must be be
      spelled exactly as shown.  For example, the statement below indi-
      cates that there are no parameters for the statement shown.

      ÄÄSTATEMENTÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


                                 Page [3]

      User-supplied parameters are indicated by lower-case text.  These
      lower-case items are to be replaced with a value determined by
      the user.  When the syntax includes a required item, it appears
      in the main line.  Optional parameters are placed in a separate
      path below the main line.

      ÄÄSTATEMENTÄÄÄÄrequired-itemÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

      ÄÄSTATEMENTÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ÀÄoptional-itemÄÄÄÙ

      Any commas, parenthesis, or other such punctuation marks must be
      entered as shown as part of the syntax.

      When the user may select from a number of alternate parameters,
      they are stacked vertically.

      ÄÄSTATEMENTÄÄÂÄrequired-item1ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ³                 ³
                     ÀÄrequired-item2ÄÄÙ

      ÄÄSTATEMENTÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ÃÄoptional-item1ÄÄ´
                     ³                 ³
                     ÀÄoptional-item2ÄÄÙ

      Single arrowheads have special meanings in the syntax diagrams.
      A right arrowhead at the end of a main line indicates that the
      diagram is continued, while a right arrowhead at the beginning of
      a main line indicates that it is a continuation of a preceding
      main line.

      ÄÄSTATEMENTÄÄÂÄrequired-item1ÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄ
                     ³                 ³  ³                 ³
                     ÀÄrequired-item2ÄÄÙ  ÃÄoptional-item1ÄÄ´
                                          ³                 ³
                                          ÀÄoptional-item2ÄÄÙ

      ÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                   ÀÄoptional-item3ÄÄÙ

      Items which may optionally be repeated in a syntax are indicated
      by an arrow which returns to an earlier point in the path
      containing those items.

      ÄÄSTATEMENTÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ³ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿³
                     ÀÄrepeatable-itemÄÁÙ









                                 Page [4]




                                Chapter 2.
                                Using REXX




      REXX macros used with SPF/PC have the following characteristic:

      1. The first line in the macro must be a comment in the form:

             /* ... */

      2. The second line in the macro must be:

             'ISREDIT MACRO'

      3. Subsequent lines may be REXX instructions intermixed with
         ISREDIT statements as desired.

      4. REXX macros for SPF/PC have are named in the following manner:

          macro-name.SPF

      and placed in either directory \SPFPC30 or the directory speci-
      fied in panel 0.5 for SPF macro path.

      1. REXX macros are invoked by specifying the macro in the primary
         command field and pressing SPF-ENTER.


   Limits

      This section lists the implementation limits for CTC REXX.  These
      limits are mainly for reference; most REXX programs will not be
      affected by them.

      *  The size of a REXX program will vary depending on your avail-
         able memory and how you set the environmental variables.  REXX
         compiles source code into pseudo-code, and the pseudo-code for
         a single module must fit within 64K, but the actual source
         code can be much larger.

      *  The total size of all variables is limited only by the amount
         of virtual storage available to SPF/PC.  This will vary
         depending on your available memory and how much disk space is
         available for swapping or paging.

      *  The total static nesting of control structures (IF, SELECT,
         DO, and so forth) is 250.

      *  The largest allowable exponent is 999,999,999.



                                 Page [5]

                        Table 1. REXX Maximum Lengths


                           Item                       Maximum length

       Single line                                  250 characters
       Variable name                                250 characters
       Symbol (before substitution)                 250 characters
       Literal string                               250 characters
       Single "clause" (tokenized internal format)  250 tokens
       Single "token"                               250 characters
       Argument of INTERPRET instruction            32,700 characters
       Variable                                     32,700 characters

                        Table 2. REXX Maximum Numbers


                                             Maximum
                                Item         number

                         Function arguments    30
                         Open files            250



   Comparison of Built-In Functions

      The following table provides a comparison of Built-In Functions
      for VM/SP CMS REXX (CMS), M.F. Cowlishaw's definition (COW),
      Systems Application Architecture Procedures Language (SAA), and
      CTC REXX.

                  Table 3. Comparison of Built-in Functions


                     Availability of Built-in Functions

                      Function    SAA   COW   CMS   CTC

                     ABBREV        x     x     x     x
                     ABS           x     x     x     x
                     ADDRESS       x     x     x     x
                     ARG           x     x     x     x
                     BITAND        x     x     x     x
                     BITOR         x     x     x     x
                     BITXOR        x     x     x     x
                     B2X           x     -     -     x
                     CENTER        x     x     x     x
                     CHARIN        x     x     -     x
                     CHAROUT       x     x     -     x
                     CHARS         x     x     -     x
                     COMPARE       x     x     x     x
                     CONDITION     x     -     -     x
                     COPIES        x     x     x     x
                     C2D           x     x     x     x
                                          continued ...

                                 Page [6]


                     Availability of Built-in Functions

                      Function    SAA   COW   CMS   CTC
                     C2X           x     x     x     x
                     DATATYPE      x     x     x     x
                     DATE          x     x     x     x
                     DELSTR        x     x     x     x
                     DELWORD       x     x     x     x

                     DIGITS        x     x     x     x
                     D2C           x     x     x     x
                     D2X           x     x     x     x
                     ERRORTEXT     x     x     x     x
                     FORM          x     x     x     x
                     FORMAT        x     x     x     x
                     FUZZ          x     x     x     x
                     INSERT        x     x     x     x
                     LASTPOS       x     x     x     x
                     LEFT          x     x     x     x
                     LENGTH        x     x     x     x
                     LINEIN        x     x     -     x
                     LINEOUT       x     x     -     x
                     LINES         x     x     -     x
                     MAX           x     x     x     x
                     MIN           x     x     x     x
                     OVERLAY       x     x     x     x
                     POS           x     x     x     x
                     QUEUED        x     x     x     x
                     RANDOM        x     x     x     x
                     REVERSE       x     x     x     x
                     RIGHT         x     x     x     x
                     SIGN          x     x     x     x
                     SOURCELINE    x     x     x     x
                     SPACE         x     x     x     x
                     STREAM        x     -     -     x
                     STRIP         x     x     x     x
                     SUBSTR        x     x     x     x

                     SUBWORD       x     x     x     x
                     SYMBOL        x     x     x     x
                     TIME          x     x     x     x
                     TRACE         x     x     x     x
                     TRANSLATE     x     x     x     x
                     TRUNC         x     x     x     x
                     VALUE         x     x     x     x
                     VERIFY        x     x     x     x
                     WORD          x     x     x     x
                     WORDINDEX     x     x     x     x
                     WORDLENGTH    x     x     x     x
                     WORDPOS       x     x     x     x
                     WORDS         x     x     x     x
                     XRANGE        x     x     x     x
                     X2B           x     -     -     x
                     X2C           x     x     x     x
                                          continued ...

                                 Page [7]


                     Availability of Built-in Functions

                      Function    SAA   COW   CMS   CTC
                     X2D           x     x     x     x



   Differences from CMS REXX

      This section lists the incompatibilities between CTC REXX and CMS
      REXX (as of VM/SP Release 6).

      *  The underlying character set for CTC REXX is ASCII instead of
         EBCDIC.

      *  Trace output is not indented according to the logical level of
         nesting for DO loops.

      *  Programs written for CMS REXX that make use of CMS commands
         and file naming conventions will have to be changed to run
         with CTC REXX.

      *  CTC REXX does not support the double byte character set.

      *  Since ASCII does not have a character for logical negation,
         REXX provides several alternatives. Wherever a logical not
         sign ( ª ) is used in CMS REXX, you can use either a ( ª ),
         backslash  ( \ ), or ( ^ ). A forward slash ( / ) is sometimes
         used in CMS REXX for negation, so REXX accepts it in the same
         cases, but we do not recommend its use.  The preferred
         character is backslash ( \ ).

      *  Quoted strings must fit on one line. In CMS REXX, quoted
         strings are allowed to cross line boundaries.

      *  REXX re-evaluates the DATE and TIME built-in functions on
         clause boundaries, rather than once in each expression evalu-
         ation.


















                                 Page [8]




                                Chapter 3.
                           Language Definition




   Clauses

      A REXX program is built out of a series of clauses.  Clauses are
      made up of blanks and tokens.  To place multiple clauses on one
      line, separate them with semicolons ( ; ).  To continue long
      clauses on the next line, use a comma ( , ).


   Tokens

      The REXX language is composed of tokens, which can be up to 250
      characters long.  Each clause can contain up to 250 tokens.

      Tokens are either separated by blanks or by the characteristics
      of the tokens themselves.

      The tokens are:

      *  Comments

      *  Literal strings

      *  Hexadecimal strings

      *  Symbols

      *  Numbers

      *  Operators

      *  Special characters


   Comments

      A comment is any sequence of characters of one or more lines that
      start with a   /*   and end with a   */  .  For example:

      /* This is a comment */

      You can nest comments, as long as the  /*  and  */  pair
      correctly.  You can put comments anywhere, and they can be as
      long as you like.

      Comments have no effect on the program, except that they act as
      separators.  For example, if you put a comment in between two
      tokens, REXX treats the tokens separately.

                                 Page [9]

      We recommend that you start all your REXX programs with a comment
      that describes the program.


   Literal strings

      A literal string is a sequence of any characters, up to 250 char-
      acters long.  Literal strings are delimited by the single quote
      character ( ' ) or the double quote ( " ).

      A literal string is a constant and REXX never modifies its
      contents.  Literal strings must be complete on a single line
      (this means that quotes must match on a single line).

      A literal string that contains no characters (that is, a string
      of length 0) is called a null string.

      For example, these are valid literal strings:

      'Rick'
      "Say When"
      'You can''t'     /* Same as "You can't" */
      ''               /* A null string       */

      Note:  If a literal string is followed immediately by a left
      parenthesis, REXX recognizes it as the name of a function.    If
      a literal string is followed immediately by an "X", REXX recog-
      nizes it as a hexadecimal string.


   Hexadecimal strings

      A hexadecimal string is any sequence of zero or more hexadecimal
      digits (0-9, a-f, A-F), grouped in pairs.  The first group can
      have an odd number of digits, in which case REXX assumes a '0'
      digit to the left of the first digit.  You can optionally sepa-
      rate the groups of digits by one or more blanks.  The whole
      sequence is delimited by single quotes or double quotes and imme-
      diately followed by the character "x" or "X".  (The X cannot be
      part of a longer token).  The blanks can only be present at byte
      boundaries.  Blanks are used to improve readability; REXX ignores
      them.  No leading or trailing blanks are allowed.

      To form a hexadecimal string into a literal string, REXX packs
      the hexadecimal codes.  This lets you include characters in a
      program even if you cannot enter them directly.

      These are valid hexadecimal strings:

      'ABCD'x
      "1d ec f8"X
      '123 45'x    /* Same as '01 23 45'x */





                                Page [10]

   Binary strings

      Any sequence of zero or more binary digits (0 or 1) in groups of
      eight (bytes) or four (nibbles), optionally separated by one or
      more blanks.  If the leftmost group is not a multiple of four
      digits, it is padded with up to three zeros on the left to make a
      multiple of four digits.  The string is delimited by matching
      single or double quotes and immediately followed by the character
      "b" or "B".  No leading or trailing blanks are allowed.

      These are valid binary strings:

      '01110001'b
      '0111 0001'B
      "01110001 01011010"B
      '101 1110'b


   Symbols

      Symbols are identifiers made from alphanumeric characters (A-Z,
      a-z, 0-9), and/or from the national currency symbols (including
      the symbols for dollar, cent, and pound-sterling) and/or from the
      characters @ # . ! ?  and underscore.  REXX translates any lower-
      case alphabetic character in a symbol to upper case before use.

      REXX determines a symbol's meaning depending on the context in
      which it is used.  A symbol can be a constant (such as a number),
      a keyword, a function, or the name of a variable.

      For example, these are valid symbols:

      date
      Time.Of.Day
      WHAT?

      A symbol can include other characters in one case only.  A symbol
      that starts with a digit (0-9) or period and ends in "E" or "e",
      and is followed immediately by a sign ( +  or  - ) and some
      digits is recognized as a number in exponential notation.  For
      example:

      32.1E-52
      .05E-8


   Numbers

      Numbers are character strings of one or more decimal digits.  A
      number can be preceded by a plus or minus sign, and can include a
      single period ( . ) to represent a decimal point.  A number can
      also be expressed in exponential notation:  an "E" (upper or
      lower case) followed optionally by a plus or minus sign then
      followed by one or more decimal digits defining the power of ten.



                                Page [11]

      Whenever REXX uses a character string as a number, rounding might
      occur.  The precision is specified by the NUMERIC DIGITS instruc-
      tion (the default is nine digits).

      Numbers can have leading blanks (before and/or after the sign, if
      any) and trailing blanks.  Blanks cannot be embedded among the
      digits of a number or in the exponential part.  Note that a
      symbol and a literal string can be a number.  A number cannot be
      the name of a variable.

      For example, these are valid numbers:

      -45.7
      639.0340
      22
      1E000
      -45.7
      88e+450
      ' + 2.1E3 '

      A whole number in REXX is a number that has no decimal part, and
      which does not have more digits before the decimal point than the
      current setting of the NUMERIC DIGITS instruction (the default is
      9 digits).


   Operators and special characters

      REXX defines the characters + - * / & = \ % | ª ^ > < and various
      combinations of these as operators.  One or more blank charac-
      ter(s) in an expression can also act as an operator, if they are
      not adjacent to another operator.

      REXX defines the characters , ; : ) ( and the operator tokens as
      "special characters", because they have special significance when
      placed outside of literal strings.  They all act as token deli-
      miters.  REXX removes any blanks adjacent to them, with the
      exception that it only deletes a blank adjacent to the outside of
      a parenthesis if it is also adjacent to another special charac-
      ter.

      For example, the following clause is made up of six tokens:

      'ERASE'     Z - 3;

      The tokens are:  a literal string, a blank operator, a symbol
      (which can have a value), an operator, a second symbol (a
      number), and a semicolon.  REXX removes the blanks between the
      "Z" and the "-" and between the "-" and the "3".  One of the
      blanks between the "ERASE' and the "Z" remains as an operator.
      With the blanks removed, the clause is the same as:

      'ERASE' Z-3;




                                Page [12]

   Implied semicolons

      REXX implies a semicolon at the end of each line, except if:

      1. The line ends in the middle of comment.

      2. The last non-comment token was a comma.  In this case the
         comma is functionally replaced by a blank, and acts as a
         continuation character.

      This means that you only need to use semicolons to separate
      multiple clauses on a single line.

      Notes:

      1. REXX adds semicolons automatically after colons (when
         following a single symbol, a label) and after certain keywords
         (ELSE, OTHERWISE, and THEN) when in the correct context.

      2. The comment delimiter character pairs /* and */ cannot be
         split by a line-end.  If they are split, REXX cannot recognize
         them.


   Program Execution

      REXX ignores the blanks and scans each clause from left to right
      before it identifies the tokens and executes.  As the program
      executes, REXX:

      1. Recognizes instruction keywords, removes the comments, and
         reduces multiple blanks to single blanks (except within
         literal strings).

      2. Removes any blanks adjacent to special characters (including
         operators).





















                                Page [13]




                                Chapter 4.
                                 Clauses




      A REXX program consists of a number of clauses.    A clause can
      be:

      *  A keyword instruction that tells REXX to do something; for
         example:

         say "enter your password"

         This keyword instruction tells REXX to display "enter your
         password" on the user's screen.

         Instructions control the external interfaces, the flow of
         control, and so on.  Some instructions, such as DO, can
         include nested instructions.  See "Keyword Instructions" on
         page 28.

      *  A null clause, such as a blank line or a comment line.  For
         example:

         ;

         REXX ignores a null clause, unless it is a comment line, in
         which case it is traced, if appropriate.

         Note: A null clause is not an instruction.  So, for example,
         if you put an extra semicolon after the THEN or ELSE in an IF
         instruction, it is not equivalent to a dummy instruction (as
         it is in PL/I).  REXX provides the NOP instruction for this
         purpose.

      *  A label, which is a single symbol followed by a colon.  For
         example:

         SUBNAME: REPEAT

         In this example, SUBNAME: is a label that tells REXX the name
         of a subroutine.

         The colon after a label implies a semicolon (clause separa-
         tor), and so a label is a clause in its own right and does not
         require a semicolon.  You can use labels to identify the
         targets of CALL instructions, SIGNAL instructions, and
         internal function calls.

         For example, the instruction:

         CALL SUBNAME

                                Page [14]

         tells REXX to search for the label SUBNAME:.

         You can also trace labels to aid debugging.

         Any number of successive clauses can be labels.   This permits
         multiple labels before other clauses.  REXX permits duplicate
         labels, but passes control only to the first of any duplicates
         in a program.  You can trace other duplicate labels, but you
         cannot use them as a target of a CALL, SIGNAL, or function
         invocation.

      *  An assignment, which gives a variable a new value.  For exam-
         ple:

         Message = 'The total'

         This means that the string "The total" is to be put into a
         place called "Message" in the computer's memory.  See "Vari-
         ables" on page 21.

         Anything that is not an instruction, an assignment, a label,
         or a null clause is taken to be:

      *  A command that is passed to the system.  For example:

         dir    /* display current directory */

         A command is a single clause that consists of just an expres-
         sion. The system processes the command just as if you had
         typed the command at the command prompt.  See "System
         Commands" on page 27.


























                                Page [15]




                                Chapter 5.
                               Expressions




      Clauses can contain expressions.  An expression is something that
      can be computed.

      Expressions combine one or more pieces of data in various ways to
      produce a result, usually different from the original data.

      For example:

      1 + 1      /* The value is '2'     */


   Operators and Terms

      An expression can include operators that operate on one or more
      terms.


   Terms

      A term can be:

      *  Literal strings (character strings delimited by quotes), which
         are constants.

      *  Symbols (no quotes), which REXX translates to upper case.
         Those symbols that do not begin with a digit or a period can
         be the name of a variable, in which case REXX uses the value
         of that variable.  Otherwise, REXX treats them as a constant
         string.  A symbol can also be compound.  See "Compound
         symbols" on page 23.

      *  Function calls (see "Functions" on page 75) which are of the
         form:

         ÄÂÄsymbol(ÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄ
            ³         ³  ³ ÚÄÄÄÄÄÄÄ,ÄÄÄÄÄÄ¿ ³
            ÀÄstring(ÄÙ  ÀÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÁÄÙ
                            ÀÄexpressionÄÙ

      *  Subexpressions, which consist of any expression bracketed by a
         left and right parenthesis.


   Operators

      Operators are divided into four groups:  concatenation, arithme-
      tic, comparative, and logical.

                                Page [16]

   Concatenation operators

      Concatenation operators combine two strings to form one string.
      REXX appends the second string to the right end of the first
      string.  The concatenation can occur with or without an
      intervening blank.  For example:

                      Table 4. Concatenation Operators


        Operator                      Description

        (blank)   Concatenate terms with one blank in between
           ||     Concatenate terms without an intervening blank
       (abuttal)  Concatenates a literal string and a symbol without
                  an intervening blank.  For example, if the variable
                  SUM had the value '13.7', then SUM'%' evaluates to
                  '13.7%'.


   Arithmetic operators

      Arithmetic operators combine character strings that are valid
      numbers.  The arithmetic operators are:

                        Table 5. Arithmetic Operators


        Operator                      Description

           +      Add
           -      Subtract
           *      Multiply
           /      Divide
           %      Integer divide.  Divide and return the integer part
                  of the result.
           //     Remainder.  Divide and return the remainder (not
                  modulo, as the result might be negative).
           **     Power.  Raise a number to a whole-number power.
        Prefix -  Same as the subtraction:  "0-number".
        Prefix +  Same as the addition:  "0+number".

      See "Numerics and Math" on page 183.


   Comparative operators

      Comparative operators return the value '1' if the result of the
      comparison is true, or '0' if false.  REXX defines two types of
      comparative operators:  the strict comparisons and the normal
      comparisons.

      The strict comparative operators all have one of the characters
      defining the operator doubled.  The "==" and "\==" operators test
      for strict equality or inequality between two strings.  These
      operators are useful if you are interested in leading and

                                Page [17]

      trailing blanks, nonsignificant zeros and so forth.  The two
      strings must be identical before they are considered strictly
      equal.  Similarly, the other strict comparative operators (such
      as ">>" or "<<") carry out a simple character-by-character
      comparison, with no padding of either of the strings being
      compared.

      For all the other comparative operators, if both the terms
      involved are numeric, REXX performs a numeric comparison in which
      leading zeros are ignored, and so forth  (see "Comparing Numbers"
      on page 187).  Otherwise, REXX treats both terms as character
      strings.    For character string comparison, REXX ignores leading
      and trailing blanks, and pads the shorter string with blanks on
      the right.  The character comparison operation is case sensitive,
      and (as for strict comparisons) the exact collating order might
      depend on the character set used.

      Normal comparative operators are:

                    Table 6. Normal Comparative Operators


                 Operator            Description

                 =        True if the terms are equal
                 ª=, \=,  Not equal (inverse of =).
                 ^=
                 >        Greater than.
                 <        Less than.
                 ><, <>   Greater than or less than (same as
                          not equal).
                 >=, ª<,  Greater than or equal to, not less
                 \<, ^<   than.
                 <=, ª>,  Less than or equal to, not greater
                 \>, ^>   than.



      Strict comparative operators are:

                    Table 7. Strict Comparative Operators


                  Operator             Description

                ==           True if the terms are strictly
                             equal (identical).
                ª==, \==,    True if the terms are strictly
                ^==          not equal (inverse of ==).
                >>           Strictly greater than.
                <<           Strictly less than.
                >>=, ª<<,    Strictly greater than or equal
                \<<, ^<<     to, strictly not less than.
                <<=, ª>>,    Less than or equal to, not
                \>>, ^>>     greater than.


                                Page [18]

      The logical, or Boolean, operators negate or combine expressions.
      A character string is taken to have the value "false" if it is
      '0', and "true" if it is '1'. The logical operators take these
      values and return '0' or '1' as appropriate.


   Logical operators

      Logical operators are:

                         Table 8. Logical Operators


            Operator                     Description

         &               And.  Returns 1 if both terms are true.
         |               Inclusive or.  Returns 1 if either term is
                         true.
         &&              Exclusive or.  Returns 1 if either (but not
                         both) is true.
         Prefix ª, \, ^  Logical not.  Negates; 1 becomes 0 and 0
                         becomes 1.

      Most operators act on two terms, and there are at least one of
      these dyadic operators between every pair of terms.  A term can
      also contain prefix (monadic) operators, that act on the term
      immediately to the right of the operator.  A term can have one or
      more prefix operators to the left.


   Parentheses and operator precedence

      REXX resolves expressions from left to right.    You can modify
      this by using parentheses, because expressions in parentheses are
      resolved first.  Also, some operators have a greater priority
      than others, and are always executed first.

      The order of precedence of the operators is (highest at the top):

                        Table 9. Operator Precedence


                  Operator                      Description

        + - ª \ ^                     Prefix operators
        **                            Power operator
        * / % //                      Multiplication and division
                                      operators
        + -                           Addition and subtraction opera-
                                      tors
        (blank) || (abuttal)          Concatenation operators
        =  ==  >  <  >=  ª>  <<  \>>  Comparison operators
        etc.
        &                             And
        |  &&                         OR, exclusive OR


                                Page [19]

      For example,  *  (multiply) has a higher precedence than  +
      (add), so 3+2*5 evaluates to 13 (rather than the 25 that would
      result if strict left to right evaluation occurs).  If you wanted
      to perform the addition before the multiplication, you could
      write the expression (3+2)*5, which forms the first three tokens
      into a subexpression by adding the parentheses.

      When REXX encounters parentheses, it evaluates the entire subex-
      pression between the parentheses immediately when the term is
      required.

      REXX resolves the whole expression, except when an error occurs
      during the resolution.

      REXX resolves each term in an expression as it is used.  The
      result is a "typeless" character string.  Consequently, the
      result of evaluating any expression is itself a typeless
      character string.  All terms and results can be the null string
      (a character string of length 0).  REXX does not impose any
      restriction on the maximum length of results, but there are
      usually some practical limitations, depending on the amount of
      storage and other resources available during execution.

      Note: The REXX order of precedence has one difference from some
      common notations:  the prefix minus operator always has a higher
      priority than the exponential operator.  For example:

      -3**2       @ 9  /* not -9 */
      -(2+1)**2   @ 9  /* not -9 */

      In the following examples, suppose that the symbol A is a vari-
      able whose value is '3', and DAY is a variable with the value
      "Sunday".

      a+5             @ '8'
      a-4*2           @ '-5'
      a/2             @ '1.5'
      0.5**2          @ '0.25'
      (a+1)>7         @ '0'     /* False */
      ' '=''          @ '1'     /* True  */
      ' '==''         @ '0'     /* False */
      ' '^==''        @ '1'     /* True  */
      ' 'ª==''        @ '1'     /* True  */
      (a+1)*3=12      @ '1'     /* True  */
      '077'>'11'      @ '1'     /* True  */
      '077'>>'11'     @ '0'     /* False */
      'abc'>>'ab'     @ '1'     /* True  */
      Today is day    @ 'TODAY IS Sunday'
      'If it is' day  @ 'If it is Sunday'
      substr(day,2,3) @ 'und' /* Substr is a function */
      '!'xxx'!'       @ '!XXX!'






                                Page [20]




                                Chapter 6.
                                Variables




      A variable is a particular piece of data whose value can be
      changed during the execution of a REXX program.    The process of
      changing the value of a variable is called an assignment.  In an
      assignment, you name a variable and give it a value.  You can use
      an assignment to assign an initial value to a variable or to
      change its value.  A variable's value changes, not its name.

      The value of a variable is a single character string, of any
      length, that can contain any characters.


   Symbols

      A symbol is the name of the variable, for example, rick is the
      symbol in this assignment:

      /* Next line gives RICK the value 'Richard' */
      rick='Richard'

      The most common way to change the value of a variable is to use
      an assignment clause.  Any clause of the form:

      ÄsymbolÄ=ÄexpressionÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

      is an assignment.  REXX resolves what the expression is and puts
      the result into the variable called symbol.

      You can also assign a new value to a variable using the ARG,
      PARSE, or PULL instructions.  See "Parsing" on page 175.


   Selecting a name for a variable

      Choosing descriptive variable names can do a great deal to
      improve the clarity of your program.  For example, the variable
      name total is much more meaningful than t.  However, if the vari-
      able represents a temporary concept, such as a loop index vari-
      able, a short name might be best.

      You can select any symbol as the name of a variable, with these
      restrictions:

      1. The first character must be one of:

         A B C ... Z @ # $  ! ? _ 



                                Page [21]

         The symbol that names the variable cannot begin with a digit
         (0-9) or a period.

      2. The rest of the characters can be any of the above, or 0
         through 9 or period ( . ).

      Note: You should not use a period in a variable name unless you
      understand the rules for compound symbols.  See "Compound
      symbols" on page 23.


   Initial values

      You can use symbols in an expression even if they have not been
      assigned a value.  When REXX finds a symbol (a word that is not
      in quotes) it looks to see if the symbol has been given a value.
      If so, REXX substitutes that value for the symbol.  If not, the
      variable is uninitialized, and REXX translates the symbol to
      uppercase and uses that.  For example:

      /* If "richard" has not been assigned a value, */
      /* next line gives RICK the value 'RICHARD'    */
      rick=richard


   Types of Symbols

      The meaning of a symbol varies according to its context.  When
      you use a symbol as a term in an expression (rather than as a
      keyword of some kind, for example), symbols are divided into four
      groups:  constant symbols, simple symbols, compound symbols, and
      stems.


   Constant symbols

      A constant symbol is simply the string that consists of the char-
      acters of the symbol.  You cannot assign a new value or change
      the value of a constant symbol.  The symbol starts with a digit
      (0-9) or a period.  REXX translates any alphabetic characters to
      upper case.

      These are constant symbols:

      77
      827.53
      .12345
      12e5           /*Same as 12E5 */


   Simple symbols

      A simple symbol is used for variables where the name corresponds
      to a single value.  By default the value of a simple symbol is



                                Page [22]

      the characters of the symbol, translated to upper case.  If you
      assign a value to the symbol, it names a variable and its value
      is the value of that variable.

      A simple symbol does not contain any periods, and does not start
      with a digit (0-9).

      These are simple symbols:

      RICK
      Reallybigmoney  /*Same as REALLYBIGMONEY */
      $25


   Compound symbols

      A compound symbol is used to build complex collections of vari-
      ables, such as arrays, records, and lists.  Compound symbols have
      one or more periods, which divide them into two parts.

      Here are examples of compound symbols:

      rick.3
      Array.R.N
      ADIFFICULT..C.2.

      The leftmost part is a regular variable name, followed by a
      period.  This part is called the stem.  For example:

      rick.3

      The stem contains at least one period, and at least one other
      character.  It cannot start with a digit or a period.

      The rest of the compound symbol is composed of parts that are
      separated by a period.  If there is only one period, it cannot be
      the last character.  This is the tail.  A tail can be composed of
      constant symbols, simple symbols, or can be null.  For example:

      rick.3


   How REXX processes compound symbols

      Before REXX uses a compound symbol, it first generates a derived
      compound symbol name.


   Stem assignment

      If you have not assigned a value to the stem, by default its
      value is the symbol itself, translated to uppercase.

      By assigning a value to the stem, you can set all possible
      compound variables derived from the same stem.  Any reference to


                                Page [23]

      any compound variable with that stem will use the original stem
      assignment, until you assign a new value to the stem.


   Tail assignment

      To generate a derived name for the tail, REXX substitutes the
      values of any simple symbols in the tail by their values.  The
      value substituted can contain any characters (including periods).
      Substitution is only done once.

      For example, for the compound symbol array.r.n, REXX sets the
      simple symbols r and n to their values.  So if r was set to 3,
      and n was set to 5, the new derived name for the compound symbol
      is array.3.5.

      If you have not assigned values for the simple symbols, REXX uses
      their own name in uppercase, for example, ARRAY.R.N.

      Note: The value that has been assigned to the whole collection of
      variables can always be obtained by using the stem.

      You can also manipulate collections of variables, referred to by
      their stem, using the DROP and PROCEDURE instructions.  For exam-
      ple, "DROP RICK." drops all variables with that stem, and
      "PROCEDURE EXPOSE RICK." exposes all possible variables with that
      stem.


   Using compound symbols as arrays

      REXX's compound symbols are even more powerful than high-level
      data types in other languages, because their subscripts do not
      have to be numeric.  This lets you create trees, lists, and
      tables that usually need complex string manipulation and memory
      management.  Nonnumeric subscripts let you create high-level data
      structures that are automatically indexed by their contents.


   When to use quotes

      REXX reserves a few simple symbols in certain contexts:

      *  Within particular instructions, REXX reserves some symbols
         that separate the parts of an instruction.  For example, the
         subkeyword WHILE in a DO instruction, or the subkeyword THEN
         following an IF or WHEN clause.  In this case, THEN acts as a
         clause terminator.

      *  REXX checks simple symbols that are the first token in a
         clause and are not followed by an "=" or ":" to see if they
         are instruction keywords.

      Therefore keywords can have adverse affects when you execute a
      host command with the same name as a REXX keyword, for example,


                                Page [24]

      "QUEUE".  This is a potential problem for any program that might
      be in use for some time and needs to be very reliable.  There are
      several strategies you can use to get around this problem.
      REXX's syntax does not impose any of these rules, so the choice
      of strategy (if done at all) is voluntary.

      *  You can adopt the rule that all REXX programs must be written
         with (at least) the first word in every command enclosed in
         quotes.  For example:

         'Queue'

         This has two advantages:  it is more efficient, and you can
         use the the SIGNAL ON NOVALUE instruction to assure the
         program's integrity.

      *  You can precede such command strings with two adjacent quotes,
         which will have the effect of concatenating the null string
         onto the front.  For example:

         ''Queue

      *  You can enclose the entire expression (or the first symbol) in
         parentheses.  For example:

         (Queue)

      Notes:

      1. REXX supports variable names whose length, after substitution,
         might become 250 characters.

      2. When you change a variable by the ARG, PARSE, or PULL instruc-
         tions, the effect is identical to an assignment.  Therefore,
         if you use a stem in a parsing template, it can set an entire
         collection of variables.

      3. Since an expression can include the operator "=", and an
         instruction can consist purely of an expression, there is a
         potential ambiguity which is resolved by the following rule:
         any clause that starts with a symbol and whose second token is
         "=" is an assignment, rather than an expression.  This is not
         a restriction, since the clause can be executed as a command
         in several ways, such as by putting a null string before the
         first name or by enclosing the first part of the expression in
         parentheses.

         If you unintentionally use a REXX keyword as the variable name
         in an assignment, it is not an error.  For example, the
         following clause is an assignment, not a CALL instruction:

         call='466-7002';

      4. You can use the SYMBOL function to test whether a symbol has
         been assigned a value.  You can also set SIGNAL ON NOVALUE to


                                Page [25]

         trap the use of any uninitialized variable.  See the SYMBOL
         built-in function on page 153, and the SIGNAL instruction on
         page 68.


   Special Variables

      REXX has three special variables that it might set automatically
      during program execution:

      RC     Contains the value set by the last host command executed
             (including those submitted with the ADDRESS instruction).
             Following the SIGNAL events ERROR, FAILURE, and SYNTAX, it
             is set to the command return code or the syntax error
             number (1-99).  RC is unchanged following a NOVALUE or
             HALT event.

      RESULT Contains the value set by a RETURN instruction, if it
             specifies an expression.  If the RETURN instruction does
             not specify an expression, RESULT is dropped (becomes
             uninitialized).

      SIGL   Contains the line number of the last call to a label (that
             is, any SIGNAL, CALL, internal function invocation, or
             trapped error condition).

      The special variables do not have an initial value.  A user can
      alter them, just like any other variable, but REXX will continue
      to set them automatically when appropriate.  The PROCEDURE and
      DROP instructions also affect these variables in their usual way.



























                                Page [26]




                                Chapter 7.
                             System Commands




      REXX lets you execute system commands.

      REXX selects the system environment as the active environment for
      executing commands on entry to a REXX program.

      To send a command to the system, use a clause of the form:

      ÄexpressionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

      REXX evaluates the expression, which results in a character
      string that is sent to the system. The system executes the
      command, which might have side effects.  The system eventually
      returns control to REXX, after it sets a return code. REXX places
      this return code in the special variable RC.

      If an error or failure occurs, the system indicates the error or
      failure to REXX. An error is a condition for which a program that
      uses that command would normally be expected to be prepared.  A
      command failure occurs when a program that uses that command
      would not normally be expected to recover (for example, if the
      command was not executable or could not be found).

      Errors and failures in commands directly affect REXX execution if
      CALL ON ERROR, CALL ON FAILURE, SIGNAL ON ERROR, or SIGNAL ON
      FAILURE is in effect.  To trace the command, set TRACE E or TRACE
      F.  TRACE Normal is the same as TRACE F, and is the default.






















                                Page [27]




                                Chapter 8.
                           Keyword Instructions




      A keyword instruction is one or more clauses that perform
      actions, such as:

      *  Directing the flow of execution

      *  Controlling input and output

      *  Controlling arithmetic operations

      *  Executing other instructions

      The first clause of a keyword instruction begins with a keyword
      that identifies the instruction.

      REXX recognizes a keyword instruction if:

      1. Its keyword is the first token in a clause, and

      2. The second token is neither an equals sign (which indicates an
         assignment) nor a colon (which indicates a label).

      REXX uses the same rules to recognize the keywords ELSE, END,
      OTHERWISE, THEN and WHEN.  If these keywords are not in their
      correct position in a DO, IF, or SELECT instruction, REXX issues
      a syntax error.

      Instruction keywords are not reserved, therefore you can use them
      as labels or as the names of variables.  However, we recommend
      that you use them only as instructions.

      Some instructions have subkeywords that might be reserved within
      the clauses of the instructions.  For example, the symbols TO and
      WHILE in the DO instruction.  The DO instruction is described on
      page 37.














                                Page [28]

   --------------------------------------------------------------------
                                 ADDRESS
   --------------------------------------------------------------------


   Purpose

      Effects a temporary or permanent change to the destination of
      commands.  Commands are strings sent to an external environment.
      They can also be sent by clauses that consist of just an expres-
      sion, without using the ADDRESS instruction.

   Syntax

      ÄADDRESSÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄ
                  ÃÄenvironmentÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ´
                  ³             ÀÄexpressionÄÙ  ³
                  ÀÂÄÄÄÄÄÄÄÂÄÄÄexpressionÄÄÄÄÄÄÄÙ
                   ÀÄVALUEÄÙ

   Parameters

      environment The name of the environment to which you want to send
                  a command.  Environment is a single symbol or literal
                  string, which is taken as a constant.

                  REXX resolves the expression, and submits the
                  resulting command string to the environment.  After
                  the command executes, environment is returned to its
                  previous setting.

                  If you specify the null string as the environment,
                  ADDRESS sends commands to the system.

      VALUE       Makes a lasting change to the environment.

   Example

      To send a single command to a select environment, specify the
      environment name, followed by an expression.  For example, the
      following instruction sends the command "DIR MDV1.ALL" to the
      environment called CMD:

      address CMD 'DIR MDV1.ALL'

      REXX sets the special variable RC, just as it does for other
      commands.  See page 26.  It also traps or traces any errors or
      failures in the commands, as usual.









                                Page [29]

   Example

      Use VALUE to make a lasting change to the environment.

      ADDRESS ('ENVIR' || number)

      In this example, REXX resolves the expression (which can be just
      a variable name), and the result forms the name of the environ-
      ment.  You can omit VALUE as long as the expression starts with a
      special character, so that it cannot be mistaken for a symbol or
      a string.

   Example

      If you specify only an environment name, ADDRESS selects a new
      environment for commands.  This routes all following commands to
      a new command environment, until you execute the next ADDRESS
      instruction.  REXX saves the previously selected environment.

      address CMD      /* Send command to the system */
      'RENAME *.DOC *.TXT'

      if rc=0 then
         'COPY *.TXT *.SPF /V'
      address SPF2     /* Now all commands to SPF/2 */

   Remarks

      1. If you execute the ADDRESS instruction with no arguments, it
         routes the commands back to the environment that was selected
         before the previous lasting change of environment was made,
         and saves the current environment name.  This is an easy way
         to move back and forth between two environments.

         The ADDRESS instruction automatically saves the two environ-
         ment names across subroutines and internal function calls.
         See the CALL instruction on page 33.

      2. To check or retrieve the current environment, use the ADDRESS
         built-in function.

















                                Page [30]

   --------------------------------------------------------------------
                                   ARG
   --------------------------------------------------------------------


   Purpose

      Retrieves the argument strings provided to a program or internal
      routine and assigns them to variables.

   Syntax

      ÄARGÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ÀÄtemplateÄÙ

   Parameter

      template A list of symbols separated by blanks and/or patterns.

   Remarks

      1. ARG is just a shorter form of the instruction

         ÄPARSE UPPER ARGÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄ
                             ÀÄtemplateÄÙ

         ARG translates the argument strings to upper case and parses
         them into variables according to the parsing rules. See "Pars-
         ing" on page 175.  If you do not want the argument strings
         translated to upper case, use the PARSE ARG instruction.

      2. If a subroutine or internal function is executing, ARG uses
         the argument string(s) passed to the routine.  Otherwise ARG
         uses the argument string(s) from the program invocation.

      3. You can execute the ARG (and PARSE ARG) instructions
         repeatedly (typically with different templates).  They will
         always parse the same current data.  The only restrictions on
         the length or content of the data parsed are those imposed by
         the caller.

      4. To check or retrieve the argument string(s) to a REXX program
         or internal routine, use the ARG built-in function.

      5. If more than one string is available to the program or
         routine, you can use a comma in the parsing template to select
         each string in turn.










                                Page [31]

   Example

      /* String passed to MYREXXPROG is 'Vida Loca' */

      arg adjective noun .

      /* Now:  ADJECTIVE contains 'VIDA'            */
      /*       NOUN      contains 'LOCA'            */

   Example

      This example uses a comma in the parsing template to select each
      string in turn.

      /* Function is invoked by   RICK('Now is',1,5) */

      Rick:   arg string, num1, num2

      /* Now:  STRING contains  'NOW IS'             */
      /*       NUM1   contains  '1'                  */
      /*       NUM2   contains  '5'                  */




































                                Page [32]

   --------------------------------------------------------------------
                                   CALL
   --------------------------------------------------------------------


   Purpose

      Invokes a routine.  The routine can be an internal routine, an
      external routine, or a built-in function.

   Syntax

      ÄCALLÄÄÂÄnameÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ³      ³ ÚÄÄÄÄÄ,ÄÄÄÄÄ¿ ³          ³
               ³      ÀÄÄexpressionÁÄÙ          ³
               ÃÄONÄÄconditionÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ´
               ³               ÀÄNAMEÄtrapnameÄÙ ³
               ÀÄOFFÄconditionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

   Parameters

      name       A symbol, which is taken as a constant, or a literal
                 string.  If you use a literal string for name, that
                 is, you specify the name in quotes, REXX bypasses the
                 search for internal routines, and invokes only a
                 built-in function or an external routine.  The literal
                 string must exactly match the name of the built-in
                 function or external routine, so if the name is in
                 upper case, the name in the literal string should also
                 be in upper case.

      condition  A single symbol, which is taken as a condition subkey-
                 word.  For a discussion of conditions, see "Condition
                 Traps" on page 197.  If ON or OFF are specified,
                 condition must be one of the following:

                 ERROR    Any host command returns a nonzero return
                          code.

                 FAILURE  Any host command indicates a failure upon
                          return.

                 HALT     Program execution is interrupted externally.
                          For example, pressing oCTRLpoCp to interrupt
                          the program.

                 NOTREADY REXX encountered an error during an input or
                          output operation.  See "Input and Output" on
                          page 191.

      trapname   A single symbol or literal string which is taken as a
                 constant.  For a discussion of trapnames, see "Condi-
                 tion Traps" on page 197.

      REXX resolves any expressions that follow the name from left to
      right, and forms the argument strings while it executes.

                                Page [33]

      The CALL instruction then branches to the routine called name
      using exactly the same mechanism as function calls.  See "Func-
      tions" on page 75.  The search order is:

      1. Internal(Unless you specify a literal string)  Internal
              routines are sequences of REXX instructions inside the
              same program, which start at the label that matches the
              symbol name.  The RETURN instruction completes the execu-
              tion of the routine.

      2. Built-inBuilt-in functions are defined as part of REXX.    All
              built-in functions return a string that contains the
              result of the function.

      3. ExternalA routine that resides in a separate file from the
              program that uses it is called an external routine.
              External routines can be written in any language
              (including REXX) that supports the system dependent
              interfaces used by REXX to invoke them.    The CALL
              instruction can invoke a REXX program as a subroutine,
              and in this case you can pass the program more than one
              argument string.

      Eventually the routine executes a RETURN instruction, and at that
      point control returns to the clause following the original CALL
      instruction for completion.  If the RETURN instruction specifies
      an expression, it sets the special variable RESULT to the value
      of that expression.  Otherwise it uninitializes the special vari-
      able RESULT.

   Remarks

      1. You can include up to 30 argument expressions on a CALL
         instruction.

      2. The ARG and PARSE ARG instructions (and the ARG built-in func-
         tion) access the strings that form during executionnrather
         than any active previouslynuntil control returns to the CALL
         instruction.

      3. While an internal routine executes, all variables previously
         known are accessible.  However, you can use the PROCEDURE
         instruction to set up a local variables environment to protect
         the subroutine and caller from each other.

      4. Calling an external program as a subroutine is similar to
         calling an internal routine.  However, the external routine
         protects its variables from the caller's variables and its
         internal values start with their defaults rather than
         inheriting the caller's internal values.  Another difference
         is that you can use the the EXIT instruction to return from
         the routine.

      5. To expose the selected variables to a internal routine, use
         the PROCEDURE EXPOSE instruction.


                                Page [34]

      6. REXX automatically saves the following internal values before
         executing a subroutine or function.  When the routine returns,
         REXX restores this information to its original status.

         Numeric settings:   (Set by the DIGITS, FUZZ, and FORM subkey-
         words of the NUMERIC instruction.) This means that a subrou-
         tine can set the precision it needs without affecting the
         caller.

         Address settings:   The current and secondary command destina-
         tions.  See the ADDRESS instruction on page 29.

         The status of DO loops and other control structures:   It is
         safe to execute a SIGNAL instruction within a subroutine
         because it does not deactivate any DO loops or similar
         constructions that are active when the subroutine is called.
         It does, however, deactivate any loops that are active within
         the current routine.

         Condition traps:   (CALL ON and SIGNAL ON condition) This
         means that you can use CALL ON, CALL OFF, SIGNAL ON and SIGNAL
         OFF in a subroutine without affecting the conditions set up by
         the caller.

         Condition information:   The information returned by the
         CONDITION built-in function.  See CONDITION page 102.

         Elapsed time clocks:   A subroutine inherits the elapsed time
         clock from its caller, and the clock is saved across routine
         calls.  See the TIME function on page 154.  This means a
         subroutine or internal function can independently restart and
         use the clock without affecting its caller.  For the same
         reason, a clock started within an internal routine is not
         available to the caller.

         Trace settings:   Once you debug a subroutine, you can insert
         a "TRACE Normal" at the beginning of it, and this will not
         affect the tracing of the caller.  Conversely, if you only
         wish to debug a subroutine, you could insert a "TRACE Results"
         at the start.  Upon return, tracing will automatically be
         restored to the conditions at entry (for example, "Off").

      7. When control reaches an internal routine, REXX puts the line
         number of the CALL instruction in the special variable SIGL
         (in the caller's variable environment).  You can use this as a
         debugging aid to determine the source of a call to a routine.

      8. You cannot use the symbols ON or OFF as the name in a CALL
         instruction.  They are reserved subkeywords.

      9. An internal routine can include calls to other internal
         routines, and recursive calls to itself.





                                Page [35]

   Example

      /* Example of a recursive subroutine execution. */

         arg x
         call Factorial x
         say x'! = ' result
         exit

      Factorial:  procedure /* calculate factorial by */
         arg n              /* recursive invocation.  */
         if n = 0 then
            return 1
         call Factorial n-1
         return result*n










































                                Page [36]

   --------------------------------------------------------------------
                                    DO
   --------------------------------------------------------------------


   Purpose

      DO is the most complex REXX instruction.    You can use it to:

      *  Group instructions together and execute them as one.

      *  Execute a repetitive loop and step a control variable through
         some series of values.

      *  Execute a conditional loop that is recalculated on each itera-
         tion.

   Syntax

      ÄDOÄÂÄÄÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÂ;ÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂENDÂÄÄÄÄÂÄ;Ä
            ÀrepetitorÙÀconditionalÙ ³ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿³   ÀnameÙ
                                     ÀÄinstructionÁÙ

      repetitor:

      ÄÄÄÄÄÂÄname=expriÄÂÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄ
            ³            ÀTOÄexprtÙ ÀBYÄexprbÙ ÀFORÄexprfÙ ³
            ÃÄFOREVER ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ³                                              ³
            ÀÄexprrÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

      conditional:

      ÄÄÄÄÄÂÄWHILEÄexprwÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
            ³             ³
            ÀÄUNTILÄexpruÄÙ

   Parameters

      name        Specifies the name of a control variable, which is
                  given an initial value before the first execution of
                  the instruction list.  REXX steps the control vari-
                  able each time the loop is executed.  Name is used
                  with the following subkeywords and expressions:

                  expri - Expression for Initial value.  Specifies the
                  value for the control variable the first time through
                  the loop.

                  TO exprt - Expression for To value.  Specifies the
                  value for the control variable the last time through
                  the loop.

                  BY exprb - Expression for By value.  Specifies the
                  number to add to the control variable at the end of
                  the loop.  The default for  exprb is '1'.

                                Page [37]

                  FOR exprf - Expression for For value.  Specifies the
                  number of iterations through the loop.

      FOREVER     Executes the loop as long as a condition is satis-
                  fied.

      exprr       Specifies a whole number, which is the number of
                  times to execute the loop.

      conditional Specifies a conditional loop.  conditional can be one
                  of the following:

                  WHILE exprw - Expression for While value.  Test for
                  termination, discontinue execution of DO loop if
                  while value is not met.

                  UNTIL expru - Expression for Until value.  Test for
                  termination, discontinue execution of DO loop if
                  until value is met.

      instruction Any sequence of instructions, including the more
                  complex constructions such as IF, SELECT, or the DO
                  instruction itself.

   Remarks

      1. Expri, exprb, exprf, exprr, and exprt can be any expression
         that resolves to a number.  Exprr and exprf are further
         restricted to result in a non-negative whole number.  If
         necessary, the numbers are rounded according to the setting of
         the NUMERIC DIGITS instruction.

      2. Exprw (while) or expru (until) can be any expression that
         resolves to '1' or '0'.

      3. The TO, BY, and FOR subkeywords can be in any order.  REXX
         resolves them in the order they are specified.

      4. The subkeywords TO, BY, FOR, WHILE, and UNTIL are reserved
         within a DO instruction, in that they cannot name variables in
         the expression(s) but they can be used as the name of the
         control variable.  FOREVER is also reserved, if it immediately
         follows the keyword DO.


   Simple DO group

      If you specify the DO instruction without repetitor or
      conditional, it groups a number of instructions together and
      executes them as one.  This is called a simple DO group.







                                Page [38]

      /* The two instructions between DO and END are */
      /* executed if A has the value 3.              */

         if a=3 then
            do
               a=a+2
               say 'Hello!'
            end


   Simple repetitive loop

      If you do not specify repetitor, but you specify conditional, or
      if you specify repetitor as FOREVER, REXX executes the group of
      instructions until the condition is satisfied or REXX executes an
      instruction that ends the loop.  For example:

      /* This types "The total is" at least once */
         do forever
            say 'The total is'
            if random(5)=1 then leave
         end

      To specify the number of times to execute the loop use exprr,
      which must result in a whole number.  The result determines the
      number of times the loop executes.  For example:

      /* This types "Bye" seven times */
         do 7
            say 'Bye'
         end

      If the first token of exprr is a symbol and the second token is
      an "=", REXX expects the controlled form of repetitor.


   Controlled repetitive loop

      A controlled repetitive loop specifies a control variable, name,
      which takes an initial value from the result of expri before the
      first execution of the instruction list.  REXX steps the control
      variable by adding the result of exprb before the second and
      subsequent times that it executes the instruction list.

      REXX executes the instruction repeatedly while the end condition
      (determined by the result of exprt) is not met.  If exprb is
      positive or zero, the loop terminates when name is greater than
      exprt.

      REXX evaluates the expressions expri, exprt, and exprb once only,
      before the loop begins and it sets the control variable to its
      initial value.  The expressions must result in numbers, although
      the numbers do not have to be whole.  The default value for exprb
      is 1.  If you do not specify exprt, the loop executes
      indefinitely unless it is terminated by some other condition.


                                Page [39]

      /* Displays:  5, 4, 3, 2, 1, 0, -1 */
         do i=5 to -1 by -1
            say i
         end

      DO tests the end condition at the start of each iteration (and
      after it steps the control variable, on the second and subsequent
      iterations).  If the end condition is met immediately, DO skips
      the instruction list.

      You can alter the value of the control variable within the loop
      to affect the iteration of the loop.  Although this is usually
      considered questionable programming practice, it might be appro-
      priate in some circumstances.

      Note that the control variable is referenced by name.  For exam-
      ple, if you use the compound name "A.I" for the control variable,
      altering "I" within the loop changes the control variable.

      You can further bound a controlled loop's execution by a FOR
      phrase.  To do this, specify exprf, which must evaluate to a
      non-negative whole number.  This acts just like the repetition
      count in a simple repetitive loop, and sets a limit to the number
      of iterations around the loop if it is not terminated by some
      other condition.  Like the TO and BY expressions, REXX evaluates
      it once only, when it first executes the DO instruction and
      before it gives the control variable its initial value.  Like the
      TO condition, REXX checks the FOR count at the start of each
      iteration.  For example:

      /* Displays:  0.7, 1.3, 1.9, 2.5 */
         do x=0.7 to 4.9 by 0.6 for 4
            say x
         end

      In a controlled loop, you can specify the name that describes the
      control variable on the END clause.  This enables REXX to check
      the nesting of loops automatically.  REXX checks that the name
      exactly matches the name that describes the control variable in
      the DO clause (REXX ignores alphabetic case, and does not substi-
      tute compound variables while matching).  If the name does not
      match, it raises an error.  For example:

         do k=1 to 10
            ...
            ...
         end k
      /* Checks that this is the END for K loop */

      Note: A control variable's values might be affected by the
      NUMERIC instruction settings, since normal REXX arithmetic rules
      apply when stepping the control variable.





                                Page [40]

   Conditional loop

      You can follow any of the forms of repetitor by a conditional
      phrase which can terminate the loop.  The conditional phrase can
      be either WHILE or UNTIL.  If you specify WHILE or UNTIL, REXX
      evaluates the expression that follows each time around the loop
      using the latest values of all variables (which must evaluate to
      either '0' or '1'), and executes the instruction list repeatedly
      either while the result is '1', or until the result is '1'.

      For a "WHILE" loop, REXX evaluates the condition before it
      executes the instruction list.  For an "UNTIL" loop, REXX evalu-
      ates the condition after it executes the instruction list -
      before it steps the control variable.

      /* Displays:  1, 3, 5 */
         do i=1 to 10 by 2 until i > 4
            say i
         end

      Note: You can also use the LEAVE or ITERATE instructions to
      modify repetitive loops.



































                                Page [41]

   --------------------------------------------------------------------
                                   DROP
   --------------------------------------------------------------------


   Purpose

      Restores variables to their original uninitialized state.

   Syntax

               ÚÄÄÄÄÄÄÄÄ¿
      ÄDROPÄÄÄÄnameÄÄÁÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      name   The name of one or more variables to drop, which can be
             one or more symbols, separated by blanks.  The symbols in
             name must be valid variable names.  The DROP instruction
             drops each variable name from the list of known variables,
             from left to right.  It is not an error to specify a name
             more than once, or to drop a variable that is not known.

   Example

      If you specify an exposed variable, the DROP instruction drops
      the variable owned by the original caller.

      j=4
      drop a x.3 x.j
      /* undefines the variables A, X.3, and X.4 */

   Example

      If you specify a variable as the stem of a compound variable (a
      symbol that contains only one period as the last character) all
      variables starting with that stem are dropped.

      drop x.
       /* undefines all variables whose names start with x. */

















                                Page [42]

   --------------------------------------------------------------------
                                   EXIT
   --------------------------------------------------------------------


   Purpose

      Leaves a program unconditionally, and optionally returns a data
      string to the caller.  The program terminates immediately, even
      if an internal routine is currently executing.

   Syntax

      ÄEXITÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ÀÄexpressionÄÙ

   Parameter

      expression REXX resolves the expression, and returns the
                 resulting data string back to the caller when the
                 program terminates. If you do not specify an expres-
                 sion, REXX does not pass a data string back to the
                 caller.

   Example

      j=3
      exit j*4
       /* Exits with the string '12'  */

   Remarks

      1. If no internal routine is active, RETURN and EXIT are identi-
         cal.

      2. When a program runs off the end without encountering a termi-
         nating instruction, REXX terminates the program and returns no
         result string.

      3. A REXX program does not distinguish between invocation as a
         command and invocation as a subroutine or function.  If the
         program was invoked via a command interface, REXX attempts to
         convert the returned value to a return code the host will
         accept.  If the conversion fails, it is considered a failure
         of the host interface, so you cannot trap it using the SIGNAL
         ON SYNTAX instruction.











                                Page [43]

   --------------------------------------------------------------------
                                    IF
   --------------------------------------------------------------------


   Purpose

      Conditionally executes an instruction or group of instructions.
      You can also use IF to select between two alternatives.

   Syntax

      ÄIFÄexpressionÄÂÄÂÄÄTHENÄÄÂÄÂÄinstructionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                       À;Ù        À;Ù

      ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
         ÀÄELSEÄÂÄÂÄinstructionÄÙ
                À;Ù

   Parameters

      expression REXX resolves the expression, which must result in '0'
                 or '1'.

                 *  When the result is '1', REXX executes the instruc-
                    tion that follows the keyword THEN.

                 *  When the result is '0' and you specify the ELSE
                    keyword, REXX executes the instruction that
                    follows.

      instructionAny instruction, including the complex constructions
                 such as DO and SELECT groups, and the IF instruction
                 itself.

   Remarks

      1. Remember that if the ELSE clause is on the same line as the
         last clause of the THEN part, you need a semicolon to termi-
         nate the clause following the THEN.

      2. A null clause is not an instruction, so putting an extra semi-
         colon after a THEN clause is not the same as using a dummy
         instruction (as it would be in PL/I).  Use the NOP instruction
         for this purpose.

      3. You cannot use a variable THEN within expression, because the
         keyword THEN is special, in that it need not start a clause.
         This allows REXX to terminate the expression following the IF
         by the THEN, without requiring a ";".







                                Page [44]

   Example

      if rc=0 then
         say 'Return code ok'
      else
         say 'Bad return code' rc

   Example

      The ELSE binds to the nearest IF at the same level.  Use the NOP
      instruction to eliminate errors and confusion when IF constructs
      are nested, as in the following example.

      1 IF rc \= 0 THEN
      2     IF rc = 10 THEN
      3         SAY 'Bad return code' rc
      4     ELSE
      5         NOP
      6 ELSE
      7     SAY 'Return code ok'

        3:Only rc of 10 is trapped
        4:Prevents ELSE on line 6 from being associated with IF on line
          2
        6:ELSE is associated with IF on line 1
































                                Page [45]

   --------------------------------------------------------------------
                                INTERPRET
   --------------------------------------------------------------------


   Purpose

      Executes instructions that have been built dynamically by
      resolving an expression (in contrast to instructions that already
      exist in the program).

   Syntax

      ÄINTERPRETÄÄexpressionÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      expression REXX resolves the expression, and executes it just as
                 though the result was an actual line in the program,
                 bracketed by a DO; and an END;.

   Remarks

      1. INTERPRET allows any instructions (including the INTERPRET
         instruction) as long as they are complete.  For example, a
         string of instructions cannot contain a LEAVE or ITERATE
         instruction unless it also contains the whole repetitive
         DO...END construct.

      2. REXX ignores label clauses in the interpreted character
         string.  So if you execute a SIGNAL instruction from within an
         interpreted string, it will exit that string before starting
         the label search.

      3. REXX implies a semicolon at the end of the expression during
         execution.

   Examples

      Data='RICK'
      INTERPRET Data '= 4'
      /* Will a) build the string  "RICK = 4"       */
      /*      b) execute  "RICK = 4;"               */
      /* Thus the variable RICK will be set to '4'  */

      If you are getting results that you do not understand, you might
      find it helpful to set "TRACE R" or "TRACE I" before you execute
      the INTERPRET instruction.  For example:

      /* Small program with trace on */
      trace inter
      name='Dolly'
      indirect='name'
      interpret 'say "Hello"' indirect'"!"'

      The trace shows the following:

                                Page [46]

           2 *-* name='Dolly'
             >L>   "Dolly"
           3 *-* indirect='name'
             >L>   "name"
           4 *-* interpret 'say "Hello"' indirect'"!'"
             >L>   "say "Hello""
             >V> "name"
             >O>   "say "Hello" name"
             >L>   ""!""
             >O>   "say "Hello" name"!""
             *-*  say "Hello" name"!"
             >L>   "Hello"
             >V>   "Dolly"
             >O> "Hello Dolly"
             >L>   "!"
             >O>   "Hello Dolly!"
      Hello Dolly!

      The trace shows:

      *  Lines 2 and 3 set the variables used in line 4.

      *  Line 4 then executes in two stages.  First, REXX builds the
         string to be interpreted using a literal string, a variable
         (indirect), and another literal string.  It then interprets
         the resulting pure character string, just as though it were
         part of the original program.  Since it is a new clause, REXX
         traces it as such (the second *-* trace flag under line 4) and
         executes it.

      *  It again concatenates a literal string to the value of a vari-
         able (name) and another literal string, and displays the final
         result:  "Hello Dolly!".

      For many purposes, you can use the VALUE built-in function
      instead of the INTERPRET instruction.  For example, you could
      replace line 4 in the last example by:

      say "Hello" value(indirect)"!"

      You need to use the INTERPRET instruction only in special cases,
      such as when you need to interpret more than one instruction at
      once, or when you need to evaluate an expression dynamically.














                                Page [47]

   --------------------------------------------------------------------
                                 ITERATE
   --------------------------------------------------------------------


   Purpose

      Alters the flow of control within a repetitive DO loop, that is,
      any DO construct other than that with a plain DO.  When REXX
      encounters the ITERATE instruction, it stops executing the
      instruction list and passes control back up to the DO clause,
      just as though it had encountered the END clause.  It then steps
      (iterates) any control variable and executes the instruction list
      again, unless the DO clause terminates the loop.

   Syntax

      ÄITERATEÄÄÂÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                  ÀÄnameÄÙ

   Parameter

      name   The name of the control variable of a currently active
             loop.  REXX terminates any active loops inside the one you
             select for iteration (as though it had encountered a LEAVE
             instruction).

             If you do not specify a name, ITERATE steps the innermost
             active repetitive loop.

             name must exactly match the symbol naming the control
             variable in the DO clause (in all respects except case).
             When REXX compares name with the name of the control vari-
             able, it does not substitute compound variables.

   Remarks

      1. A loop is active if it is currently executing.  If, during
         execution, the loop calls a subroutine or executes an
         INTERPRET instruction, the loop becomes inactive until the
         subroutine returns or the INTERPRET instruction completes.
         You cannot use the ITERATE instruction to step an inactive
         loop.

      2. If more than one active loop uses the same control variable,
         ITERATE selects the innermost active loop.

   Example

      /* Displays the numbers:  1, 3, 4, 5 */
         do i=1 to 5
            if i=2 then iterate
            say i
         end



                                Page [48]

   --------------------------------------------------------------------
                                  LEAVE
   --------------------------------------------------------------------


   Purpose

      Exits immediately from one or more repetitive DO loops.  A repet-
      itive DO loop is any DO construct other than one with a simple
      DO.

   Syntax

      ÄLEAVEÄÄÂÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                ÀÄnameÄÙ

   Parameter

      name   The name of the control variable of a currently active
             loop (which might be the innermost).  LEAVE terminates
             that loop and any active loops inside it, and passes
             control to the clause that follows the END that matches
             the DO clause of the selected loop.

             Name must match the control variable name on the DO
             instruction.  When the LEAVE instruction compares name
             with the name of the control variable, it does not substi-
             tute compound variables.

             If you do not specify name, LEAVE terminates the innermost
             active repetitive loop.

   Remarks

      1. The LEAVE instruction terminates execution of the group of
         instructions and passes control to the instruction following
         the END clause.  This is as though the END clause had been
         encountered and the DO loop had terminated normally, except
         that when the loop exits, the control variable (if any)
         contains the value it had when the LEAVE instruction was
         executed.

      2. A loop is active if it is currently executing.  If, during
         execution, the loop calls a subroutine or executes a INTERPRET
         instruction, the loop becomes inactive until the subroutine
         returns or the INTERPRET instruction completes.  The LEAVE
         instruction does not terminate an inactive loop.

      3. If more than one active loop uses the same control variable,
         LEAVE selects the innermost active loop.







                                Page [49]

   Example

      /* Displays the numbers:  1, 2, 3, 4 /*
         do i=1 to 10
           say i
           if i=4 then leave
         end


















































                                Page [50]

   --------------------------------------------------------------------
                                   NOP
   --------------------------------------------------------------------


   Purpose

      Acts as a dummy instruction that has no effect.  It can be useful
      as the target of a THEN or ELSE clause.

   Syntax

      ÄNOPÄÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Example

      select
        when a=b then nop         /* Does nothing */
        when a>b then say 'A > B'
        otherwise     say 'A < B'
      end

      Note: Putting an extra semicolon instead of the NOP instruction
      merely inserts a null clause, which is ignored.  The second WHEN
      clause would then immediately follow the THEN, and REXX would
      raise a syntax error.    NOP is a true instruction, however, and
      is therefore a valid target for the THEN clause.






























                                Page [51]

   --------------------------------------------------------------------
                                 NUMERIC
   --------------------------------------------------------------------


   Purpose

      Changes the way in which arithmetic operations are carried out.
      See "Numerics and Math" on page 183.

   Syntax

      ÄNUMERICÄÄÂÄDIGITSÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄ;ÄÄÄÄÄÄÄ
                  ³        ÀÄexpressionÄÙ            ³
                  ÃÄFORMÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ´
                  ³        ÃÄÄSCIENTIFICÄÄÄÄÄÄÄÄÄÄÄ´ ³
                  ³        ÃÄÄENGINEERINGÄÄÄÄÄÄÄÄÄÄ´ ³
                  ³        ÀÄÄÂÄÄÄÄÄÄÄÂÄexpressionÄÙ ³
                  ³           ÀÄVALUEÄÙ              ³
                  ÀÄFUZZÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÙ
                           ÀÄexpressionÄÙ

   Parameters

      DIGITS Controls the precision to which arithmetic operations are
             computed - see "Precision" on page 184.  If you specify an
             expression, it must evaluate to a positive whole number.
             If you do not specify an expression, NUMERIC uses the
             default value of 9.  The value it uses must always be
             larger than the FUZZ setting.

             The value for NUMERIC DIGITS can be as large as 32,700.
             However, high precisions are likely to be very expensive
             in CPU time.  We recommend that you use the default value
             whenever possible.

             Small values of NUMERIC DIGITS (for example, values less
             than 6) are generally only useful for specialized applica-
             tions.  The setting of NUMERIC DIGITS affects all computa-
             tions, so even the operation of loops might be affected by
             rounding if small values are used.

             To retrieve the current setting of NUMERIC DIGITS, use the
             DIGITS built-in function.

      FORM   Controls which form of exponential notation to use.  This
             can be either:

             SCIENTIFIC Only one, nonzero digit appears before the
                        decimal point.  This is the default.

             ENGINEERINGThe power of ten is always a multiple of three.

             VALUE      The form is taken from the result of evaluating
                        the expression.  The result must be either
                        SCIENTIFIC or ENGINEERING.

                                Page [52]

                        You can omit the subkeyword VALUE if the
                        expression does not begin with a symbol or a
                        literal string (that is, if it starts with a
                        special character, such as an operator or
                        parenthesis).

                        To retrieve the current setting of NUMERIC
                        FORM, use the FORM built-in function.

      FUZZ   Controls how many digits, at full precision, are ignored
             during a numeric comparison operation.  If you specify an
             expression, it must result in zero or a positive whole
             number and must be less than the DIGITS setting.  The
             default is 0.

             NUMERIC FUZZ temporarily reduces the value of NUMERIC
             DIGITS by its value during every numeric comparison opera-
             tion, so that the numbers are subtracted under a precision
             of DIGITS-FUZZ digits during the comparison and are then
             compared with 0.

             To retrieve the current setting of NUMERIC FUZZ, use the
             FUZZ built-in function.

      Note: The three numeric settings are automatically saved across
      subroutine and internal function calls.  See the CALL instruction
      on page 33 for more details.






























                                Page [53]

   --------------------------------------------------------------------
                                 OPTIONS
   --------------------------------------------------------------------


   Purpose

      Passes special requests to the language processor.

   Syntax

      ÄOPTIONSÄÄÄexpressionÄÄÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      expression The expression is evaluated and the result ignored.
                 The OPTIONS instruction has no effect in REXX, but is
                 provided for compatibility.

   Example

      options 'Do Nothing'



































                                Page [54]

   --------------------------------------------------------------------
                                  PARSE
   --------------------------------------------------------------------


   Purpose

      Assigns data (from various sources) to one or more variables
      according to the parsing rules.  See "Parsing" on page 175.

   Syntax

      ÄPARSEÄÄÂÄÄÄÄÄÄÄÂÄÂÄÄARGÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ
                ÀÄUPPERÄÙ ÃÄÄEXTERNALÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                          ÃÄÄNUMERICÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                          ÃÄÄLINEINÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                          ÃÄÄPULLÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                          ÃÄÄSOURCEÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                          ÃÄÄVALUEÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄWITHÄ´
                          ³         ÀÄexpressionÄÙ      ³
                          ÃÄÄVARÄnameÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                          ÀÄÄVERSIONÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

      ÄÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
          ÀÄtemplateÄÙ

   Parameters

      UPPER    Translates the character strings to upper case.  Other-
               wise no translation takes place during the parsing.

      template A list of symbols separated by blanks and/or patterns.

               If you do not specify template, PARSE does not set any
               variables, but takes action to get the data ready for
               parsing if necessary.  For example, PARSE LINEIN and
               PARSE PULL remove a line from the appropriate character
               stream or data queue, PARSE VALUE resolves the expres-
               sion, and PARSE VAR checks the variable to ensure that
               it has a value.

      ARG      Parses the string(s) passed to the program, subroutine,
               or function as the input arguments.  See the ARG
               built-in function on page 89.

               To retrieve or check the argument string(s) to a REXX
               program, use the ARG built-in function.

               template can refer to more than one string only if you
               specify PARSE ARG.  The other options process a single
               string and so you cannot include the comma as a special
               character in the template (except within a literal
               string pattern).




                                Page [55]

      EXTERNAL Parses the next string from the terminal input buffer
               (system external event queue).  This queue can contain
               data that is the result of external asynchronous events
               - such as user console input, or messages.  If that
               queue is empty, data is read from the console.  Note
               that you should not use use this mechanism for "normal"
               console input; use the more general subkeyword PULL
               instead.  Use this subkeyword only for special applica-
               tions (such as debugging) when the program stack cannot
               be disturbed.

      NUMERIC  Returns the current settings of the NUMERIC parameters:
               DIGITS, FUZZ, and FORM.  Please refer to the NUMERIC
               instruction page 52 for the possible settings of these
               parameters.

      LINEIN   Parses the next line from the default character input
               stream.  PARSE LINEIN is a shorter form of the instruc-
               tion

               ÄÄPARSEÄVALUEÄLINEIN()ÄÂÄÄÄÄÄÄÄÄÄÄÂÄ;ÄÄÄÄÄÄÄÄÄÄ
                                        ÀÄtemplateÄÙ

               If no line is available, the program pauses until a line
               is complete.  You should only use PARSE LINEIN when
               direct access to the character input stream is neces-
               sary.  You can carry out normal line-by-line dialogue
               with the user with the PULL or PARSE PULL instructions,
               to maintain generality and programmability.

               To find the number of lines available in the default
               character input stream, use the LINES built-in function.

               For example, PARSE LINEIN reads directly from the
               terminal input buffer (as opposed to the program stack).
               If the input buffer is empty, it reads from the console
               stack.

      PULL     Parses the next string from the external data queue.  If
               the external data queue is empty, PARSE PULL reads lines
               from the default character input stream.  The program
               pauses if necessary until a line is complete.

               To add strings to the head or tail of the queue, use the
               PUSH and QUEUE instructions respectively.  Other
               programs can also alter the external data queue, so it
               can be used as a means of communication between these
               programs and REXX programs.    See the PULL instruction
               on page 61.

               To find the number of lines currently in the data queue,
               use the QUEUED built-in function.





                                Page [56]

      SOURCE   Parses data that describes the source of the program
               being executed.  The string is fixed (will not change)
               during execution of the program.  The first word identi-
               fies the system or implementation under which execution
               is progressing, the second states how the program was
               invoked, and the remaining words describe the full name
               of the program.

               For example, the string contains the SYSTEM-NAME,
               followed by either "COMMAND", "FUNCTION", or
               "SUBROUTINE" depending on whether the program was
               invoked as some kind of host command, or from a function
               call in an expression, or via the CALL instruction.
               These two words are followed by the fully qualified
               program name, the program name, and the environment
               name.  Each component is separated from the previous by
               one or more blanks.

               For example:

               COMMAND C:\RX\SAMP1.REX samp1 CMD

               COMMAND C:\RX\SAMP1.CMD samp1 CMD

               FUNCTION C:\RX\FUNC.CMD FUNC CMD

      VALUE    Resolves expression, and parses the resulting character
               string.  If you do not specify an expression, PARSE
               VALUE uses the null string.

      VAR name Parses the value of the variable specified by name.  The
               name must be a symbol that is valid as a variable name
               (that is, it cannot start with a period or a digit).

               The variable itself is not changed unless it appears in
               the template.  For example, this instruction removes the
               first word from STRING, puts it in the variable WORD1,
               and assigns the remainder back to STRING:

               parse var string word1 string

               Similarly, the next instruction translates the data from
               STRING to upper case before parsing:

               parse upper var string word1 string

      VERSION  Parses information describing the language level and the
               date of the language.  This information consists of five
               words delimited by blanks:

               1. A word describing the language.  The first six char-
                  acters are "REXX".

               2. The language level description, for example, "1.00".



                                Page [57]

               3. The language release date, for example, "01 Apr
                  1990".























































                                Page [58]

   --------------------------------------------------------------------
                                PROCEDURE
   --------------------------------------------------------------------


   Purpose

      Protects all the existing variables from being changed by a
      subroutine or function by making them unknown to any instructions
      that follow.  This lets you create new variables in a subroutine
      or function, even if they have the same names as variables in the
      main program.

   Syntax

      ÄPROCEDUREÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                    ³         ÚÄÄÄÄÄÄ¿ ³
                    ÀÄEXPOSEÄÄÄnameÄÁÄÙ

   Parameters

      EXPOSE Exposes the specified variables to the caller, so that any
             references to them (including setting and dropping them)
             refer to the variables environment owned by the caller.
             This lets you share variables across the main program and
             functions or subroutines.  Any changes made to the speci-
             fied variables remain in effect, even on RETURN from the
             routine.

      name   One or more symbols separated by blanks.  The symbols must
             be valid variable names, and are exposed in sequence from
             left to right.  It is not an error to specify a name more
             than once, or to specify a name that has not been used as
             a variable by the caller.

   Remarks

      1. When the RETURN instruction executes, REXX restores the
         original variables environment, and drops any variables used
         in the routine that were not exposed.

      2. The PROCEDURE instruction must be the first instruction
         following the label.

      3. You can only use PROCEDURE with a subroutine or function.

      4. A routine need not include a PROCEDURE instruction, in which
         case the variables it manipulates are those "owned" by the
         caller.

      5. You can expose variables through several generations of
         routines, if desired, by ensuring that they are included
         (exposed) on all intermediate PROCEDURE instructions.

      6. See the CALL instruction on page 33 and the function descrip-
         tions for details and examples of how routines are invoked.

                                Page [59]

   Example

      /* This is the main program */
         j=1;  x.1='a'
         call Someproc
         say j k w       /* displays "1 9 W" */
         exit

      /* This is a subroutine */
      Someproc: procedure expose j k x.j
         say j k x.j  /* displays "1 K a"     */
         k=9; w=3     /* "W" is not exposed   */
         return

      Note that if the "X.J" in the EXPOSE list had been placed before
      the "J", then the caller's value of "J" would not have been
      visible at that time, so "X.1" would not have been exposed.

   Example

      To expose an entire collection of compound variables, specify
      their stem in name.  (The stem is that part of the name up to and
      including the first period.) The variables are exposed for all
      operations.

      /*  This exposes "J", "K", and all variables  */
      /*    whose name starts with "A." or "B."     */
      procedure expose j k a. b.
      a.1='9'   /* This sets "A.1" in the caller's  */
                /*   environment, even if it did    */
                /*   not previously exist.          */


























                                Page [60]

   --------------------------------------------------------------------
                                   PULL
   --------------------------------------------------------------------


   Purpose

      Reads a string from the external data queue.  PULL is just a
      shorter form of the instruction PARSE UPPER PULL.

   Syntax

      ÄPULLÄÄÂÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ÀÄtemplateÄÙ

   Parameter

      template A list of symbols separated by blanks and/or patterns.

               The PULL instruction will only read one string, so you
               cannot include the comma ( , ) in the template (except
               within a literal string pattern).

   Remarks

      1. The current head-of-queue is read as one string.  If you do
         not specify a template, REXX takes no further action (effec-
         tively discarding the string).  Otherwise, REXX translates the
         string to upper case and parses it into variables according to
         the parsing rules.  See "Parsing" on page 175.  If you do not
         want REXX to translate the string to upper case, use the PARSE
         instruction.

      2. If the external data queue is empty, lines are read from the
         default character input stream, and the program pauses if
         necessary until a line is complete - that is, as though PARSE
         UPPER LINEIN had been executed instead.

      3. To find the number of lines currently in the external data
         queue, use the QUEUED built-in function.

   Example

      This example uses the dummy placeholder "." on the template to
      isolate the first word the user types, ready for comparison.

      say 'Erase the file?  Answer Yes or No:'
      pull answer .
      if answer='YES'  then Erase oldfile








                                Page [61]

   --------------------------------------------------------------------
                                   PUSH
   --------------------------------------------------------------------


   Purpose

      Stacks the string resulting from the evaluation of the expression
      LIFO (Last-In, First-Out) onto the external data queue.  If you
      do not specify an expression, PUSH stacks a null string.

   Syntax

      ÄPUSHÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ÀÄexpressionÄÙ

   Example

      a='Time'
      push           /* Stacks a null line   */
      push a 7 8     /* Stacks "Time 7 8"    */

   Remarks

      To find the number of lines currently in the external data queue,
      use the QUEUED built-in function.































                                Page [62]

   --------------------------------------------------------------------
                                  QUEUE
   --------------------------------------------------------------------


   Purpose

      Appends the string resulting from the resolution of the expres-
      sion onto the tail of the external data queue.  That is, the
      string is added FIFO (First In, First Out).  If you do not
      specify an expression, QUEUE stacks a null string.

   Syntax

      ÄQUEUEÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                ÀÄexpressionÄÙ

   Example

      a='Me'
      queue a 'too'  /* Queues "Me too"    */
      queue          /* Queues a null line */

   Remarks

      To find the number of lines currently in the external data queue,
      use the QUEUED built-in function.






























                                Page [63]

   --------------------------------------------------------------------
                                  RETURN
   --------------------------------------------------------------------


   Purpose

      Returns control (and possibly a result) from a REXX program or
      internal routine to the point of its invocation.

   Syntax

      ÄRETURNÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ÀÄexpressionÄÙ

   Remarks

      1. The internal routine can be either a subroutine (see the CALL
         instruction), or a function.  If no internal routine (subrou-
         tine or function) is active, RETURN is identical to EXIT.

      2. When REXX encounters the RETURN instruction while a subroutine
         is executing, it:

         *  Evaluates the expression (if any)

         *  Returns control to the caller

         *  Sets the special variable RESULT to the value of the
            expression.

         If you do not specify an expression, RETURN: uninitializes the
         special variable RESULT and restores the various settings it
         saved at the time it encountered the CALL instruction.

      3. When REXX encounters the RETURN instruction while a function
         is executing, it:

         *  Evaluates the expression (you must specify an expression
            for a function)

         *  Returns control to the caller

         *  Sets the special variable RESULT to the value of the
            expression.  The result of the expression is used in the
            original expression at the point where the function was
            invoked.

      4. If a PROCEDURE instruction executes within the internal
         routine, it drops all variables of the current generation (and
         exposes the previous generation), after it resolves the
         expression and before the result is used or assigned to the
         special variable RESULT.




                                Page [64]

   --------------------------------------------------------------------
                                   SAY
   --------------------------------------------------------------------


   Purpose

      Writes the result of resolving the expression to the output
      stream.  It usually displays the result to the user, but the
      output destination can vary.  The result of expression can be any
      length.

   Syntax

      ÄSAYÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ÀÄexpressionÄÙ

   Remarks

      REXX writes the result of resolving the expression from the
      program via the default character output stream.  The line is
      formatted by the operating system and the hardware.  If you do
      not specify an expression, it writes the null string.

      The SAY instruction is a shorter form of the instruction

      CALL LINEOUT  ,[expression];

      except that SAY does not affect the special variable RESULT.  See
      the LINEOUT function on page 130.

   Example

      number=75
      say number 'multiplied by 3 =>' number * 3
      /* Types:       "75 multiplied by 3 => 225" */





















                                Page [65]

   --------------------------------------------------------------------
                                  SELECT
   --------------------------------------------------------------------


   Purpose

      Conditionally executes one of any number of alternative instruc-
      tions.

   Syntax

                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      ÄSELECTÄ;ÄÄWHENÄexpressionÄÂÄÂÄTHENÄÂÄÂÄinstructionÄÁÄÄÄÄ
                                    À;Ù      À;Ù

      ÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄEND;ÄÄÄÄÄÄÄÄÄÄÄ
         ÀÄOTHERWISEÄÂÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÙ
                     À;Ù ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ³
                         ÀÄÄinstructionÄÁÄÙ

   Parameters

      instruction Any valid instruction.  This may be a complex
                  instruction, such a DO..END block.

   Remarks

      1. REXX resolves each expression that follows a WHEN in turn.
         The expression must result in '0' or '1'.

         *  If the result is '1', REXX executes the instruction that
            follows the associated THEN (which can be a complex
            instruction such as IF, DO or SELECT) after which it passes
            control directly to the END.

         *  If the result is '0', REXX passes control to the next WHEN
            clause.

            If none of the WHEN expressions result in '1', REXX passes
            control to the instruction (if any) following OTHERWISE.
            If it does not find an OTHERWISE, it raises an error.

      2. A null clause is not an instruction, so putting an extra semi-
         colon after a THEN clause is not the same as using a dummy
         instruction (as it would be in PL/I).  Use the NOP instruction
         for this purpose.

      3. You cannot use a variable THEN within expression, because the
         keyword THEN is special, in that it need not start a clause.
         This allows REXX to terminate the expression on the WHEN
         clause by the THEN, without requiring a ";"nwhich is consis-
         tent with the treatment of THEN following an IF clause.




                                Page [66]

   Example

      'DIR' logfile

      select
         when rc=0 then
            do
               'PRINT' logfile
               'ERASE' logfile
               say 'File' logfile 'printed and erased'
            end
         when rc=1 then
            say logfile  'does not exist'
         otherwise
            say 'Return code "'rc'" from DIR'
            exit rc
      end /* Select */








































                                Page [67]

   --------------------------------------------------------------------
                                  SIGNAL
   --------------------------------------------------------------------


   Purpose

      Causes an abnormal change in the flow of control, or controls
      condition trapping.

   Syntax

      ÄSIGNALÄÄÂÄÄlabelnameÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄ
                 ÃÄÄÂÄÄÄÄÄÄÄÂÄexpressionÄÄÄÄÄÄÄÄÄÄÄ´
                 ³  ÀÄVALUEÄÙ                      ³
                 ÃÄONÄÄconditionÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ´
                 ³               ÀÄNAMEÄtrapnameÄÙ ³
                 ÀÄOFFÄconditionÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

   Parameters

      labelname  A single symbol or literal string, which is taken as a
                 constant.

      condition  A single symbol or literal string, which is taken as a
                 condition keyword.  For a discussion of conditions or
                 traps, see "Condition Traps" on page 197.

      trapname   A single symbol or literal string, which is taken as a
                 constant.

      To change the flow of control:

      REXX takes the label name either directly from labelname, or from
      the result of resolving the expression that follows VALUE.  You
      can omit VALUE if the expression does not begin with a symbol or
      a literal string (that is, if it starts with a special character,
      such as an operator or parenthesis).

      REXX then terminates all active pending DO loops, DO groups, IF
      constructs, SELECT constructs, and INTERPRET instructions in the
      current routine, and they cannot be reactivated.  Control then
      passes to the first label in the program that matches labelname,
      as though the search had started from the top of the program.
      The labelname must match the label exactly, unless the label name
      is a symbol, in which case REXX ignores alphabetic case.

      signal help;  /* Go to label HELP below */
        ...
        ...
      Help:
         say 'News'

      To trap exceptions:



                                Page [68]

      Specify ON to enable a particular exception trap, or OFF to
      disable a trap.  The default is OFF.  When exception trapping is
      OFF, and one of the following conditions occur, no special action
      is taken.  When exception trapping is ON and the corresponding
      condition occurs, the current instruction terminates and the
      SIGNAL instruction executes automatically.  Control passes to the
      first label in the program that matches the condition.

      The conditions are:

      ERROR    Any host command returns a nonzero return code.

      FAILURE  Any host command indicates a failure upon return.

      HALT     Program execution is interrupted externally.  For exam-
               ple, pressing oCTRLpoCp to interrupt the program.

      NOTREADY REXX encountered an error during an input or output
               operation.  See "Input and Output" on page 191.

      NOVALUE  The program used an uninitialized variable.  The vari-
               able is used as:

               *  A term in an expression

               *  The name following the VAR subkeyword of the PARSE
                  instruction

               *  An unassigned variable pattern in a parsing template

      SYNTAX   REXX detected an interpretation error.

      Once SIGNAL traps an event, its corresponding condition is
      disabled (before the SIGNAL takes place), and you must use a new
      SIGNAL ON instruction to re-enable it.  For example, if REXX
      cannot find the required label, it takes a normal syntax error
      exit, which traces the name of that label and the clause in which
      the event occurred.

      For the conditions ERROR and SYNTAX, REXX sets the special vari-
      able RC to the error return code or syntax error number respec-
      tively before transferring control to the condition label.  For
      example:

      Signal on error
      . . .
      erase      /* this command returns a nonzero  */
                 /* return code                      */
      . . .
      . . .
      ERROR:     /* program continues from here       */
      say "Return code was" rc





                                Page [69]

   Remarks

      1. REXX saves the conditions on entry to a subroutine and
         restores them when it encounters the RETURN instruction.  This
         means that you can use SIGNAL ON and SIGNAL OFF in a subrou-
         tine without affecting the conditions set up by the caller.
         See the CALL instruction on page 33.

      2. Whenever an event occurs that corresponds to an enabled condi-
         tion, the current instruction terminates and the SIGNAL
         instruction executes immediately.  This means that if an event
         occurs during an instruction, the instruction might not
         complete execution.  For example, if you specify SIGNAL ON
         SYNTAX and an interpretation error occurs during an expression
         resolution in an assignment,  the assignment will not be made.
         Note that the HALT and ERROR conditions can only occur at
         clause boundaries, but could arise in the middle of an
         INTERPRET instruction.


   The special variable SIGL

      REXX stores the program line number of the SIGNAL instruction
      that caused a jump in the special variable SIGL.  This is useful
      for SIGNAL ON SYNTAX because you can use the number of the line
      in error, for example, to control a text editor.  The code that
      follows the SYNTAX label could issue the PARSE SOURCE instruction
      to find the source of the data, then invoke an editor to edit the
      source program, positioned at the line that caused the error.


   Using SIGNAL with the INTERPRET Instruction

      If a SIGNAL instruction is issued or a trapped event occurs as a
      result of the INTERPRET instruction, REXX ignores labels within
      interpreted strings, and does not search for any labels in the
      remainder of the string(s) being interpreted.




















                                Page [70]

   --------------------------------------------------------------------
                                  TRACE
   --------------------------------------------------------------------


   Purpose

      Controls the tracing of execution of a REXX program, and is
      primarily used for debugging.  Its syntax is more concise than
      other REXX instructions, since it is commonly typed manually
      during interactive tracing.

   Syntax

      ÄTRACEÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                ÃÄÄtracesettingÄÄÄÄÄÄÄÄÄ´
                ÀÄÄÂÄÄÄÄÄÄÄÂÄexpressionÄÙ
                   ÀÄVALUEÄÙ

   Parameters

      tracesettingA symbol or literal string which is taken as a
                  constant.  The tracesetting specifies what type of
                  tracing to perform, and whether interactive tracing
                  is on or off.

   Remarks

      The trace setting is taken from either the literal tracesetting,
      or from the result of evaluating the expression following VALUE.
      The subkeyword VALUE preceding the expression may be omitted if
      the expression begins with a special character or an operator.
      If expression begins with a symbol or a literal string, VALUE
      must be specified.


   Numeric Options:

      If the setting is a positive number and tracing interactively,
      then the specified number of interactive pauses are skipped.  If
      the setting is a negative number, then tracing is inhibited for
      that number of clauses.  Tracing will resume in its previous
      state after the specified number of clauses has executed.


   Prefix Options:

      If the setting is not a number, then it may start with one or
      more "?" characters, followed by the one of the following alpha-
      betic tracesettings.  The "?" toggles the interactive trace
      setting.






                                Page [71]

   Alphabetic Options:

      Only the first character of an alphabetic setting is significant;
      all other letters are ignored.  The alphabetic settings are:

      A  (All) Traces all clauses before execution.

      C  (Commands) Traces all host commands before execution.  If the
         command results in an error or failure, then the return code
         from the command is also shown.

      E  (Error) Traces any host command resulting in an error or
         failure (after execution), together with the return code from
         the command.

      F  (Failure) Traces any host command resulting in a failure
         (after execution), together with the return code from the
         command.  This is the same as the default setting, Normal.

      I  (Intermediates) as "R" except that all terms and intermediate
         results during expression evaluation (and substituted names)
         are also traced.

      L  (Labels) Traces only labels passed during execution.  This is
         especially useful while tracing interactively, when the
         language processor pauses after each label; or if you want to
         note all internal subroutine calls and signals.

      N  (Normal) Traces nothing except host commands resulting in
         failure.  These are traced (after execution) together with the
         return code from the command.  This is the default.

      O  (Off) Traces nothing, and turns off interactive tracing.

      R  (Results) Traces all clauses before execution, together with
         the final result of any expression evaluated.  Values assigned
         during PULL, ARG, and PARSE instructions are also displayed.
         We recommend this setting for general debugging.

   Example

      trace ?r
      /* Interactive tracing is switched on if it was */
      /*   off before (or vice versa), and results    */
      /*   of expressions will now be traced          */

   Remarks

      1. If you do not specify a trace setting, or you specify the null
         string, tracing is reset to its initial setting: "Normal" and
         "Interactive tracing OFF".

      2. To retrieve the current trace setting, use the TRACE built-in
         function.  See page 156.



                                Page [72]

      3. For "TRACE A" and for "TRACE C", commands traced before execu-
         tion have the final value of the command (that is, the string
         passed to the environment) traced as well as the clause gener-
         ating it.  Whenever any command which results in an error or
         failure is traced the return code from the command is also
         traced.

      4. The trace setting is automatically saved across subroutine and
         internal function calls.  See the CALL instruction on page 33.


   Interactive tracing

      The "?" prefix on the trace setting is used to control interac-
      tive tracing.  During normal execution, executing a TRACE
      instruction with a "?" setting prefix causes interactive tracing
      to be switched on.  While tracing interactively, interpretation
      will pause after most clauses that are traced; and TRACE instruc-
      tions in the program are ignored (this is so you are not taken
      out of interactive tracing unexpectedly).  The state of interac-
      tive tracing (that is, whether it is on or off) is saved and
      restored across internal routine calls.

      As an example, the instruction:  "TRACE ?Errors" will make the
      language processor pause for input after executing any host
      command that returns a nonzero return code.

      Interactive tracing can be switched off by executing a TRACE
      instruction with a prefix "?" during an interactive pause, or by
      executing "TRACE Off".  Using the "?" prefix therefore switches
      you alternately in or out of interactive tracing.  The prefix may
      be specified more than once in the same setting, if desired, and
      each occurrence of the prefix reverses the previous setting.


   The format of TRACE output

      TRACE displays every clause that it traces with automatic format-
      ting (indentation) according to its logical depth of nesting
      etc., and might replace any control codes (for example, ASCII
      values less than '20'x) by a question mark ("?") to avoid console
      interference.  Results (if requested) are indented an extra two
      spaces and have a double quote prefixed and suffixed so that
      leading and trailing blanks are apparent.  The first clause
      traced on any line will be preceded by its line number.

      All lines displayed during tracing have a three character prefix
      to identify the type of data being traced.  The prefixes are:

      *-*    Identifies the source of a single clause, that is, the
             data actually in the program.






                                Page [73]

      +++    Identifies a trace message.  This can be an error or
             failure return code from a command (for example, +++ RC=1
             +++), a prompt message when interactive tracing starts, an
             indication of a syntax error when tracing interactively,
             or the traceback clauses after a syntax error in the
             program (see below).

      >>>    Identifies the result of an expression (for TRACE
             Results), or the value assigned to a variable during pars-
             ing, or the value returned from a call to a subroutine or
             function.

      >.>    Identifies the value "assigned" to a placeholder during
             parsing.

      The following prefixes are only used if "TRACE Intermediates" is
      in effect:

      >V>    The string traced is the contents of a variable.

      >L>    The string traced is literal (constant symbol, uninitial-
             ized variable, or literal string).

      >F>    The string traced is the result of a function call.

      >P>    The string traced is the result of a prefix operation.

      >O>    The string traced is the result of an operation on two
             terms.

      >C>    The string traced is the name of a compound variable.  It
             is traced after substitution and before use, provided that
             the name had the value of another variable substituted
             into it.

      If a syntax error occurs and it is not trapped by SIGNAL ON
      SYNTAX, then the clause in error will be traced, as will any CALL
      or INTERPRET instructions or caused with function invocations
      active at the time of the error.  If the error was caused by an
      attempted jump to a label that could not be found, that label is
      also traced.  These traceback lines are identified by the special
      trace prefix +++.

      Notes:

      1. When a loop is being traced, the DO clause itself is traced on
         every iteration of the loop.

      2. Tracing may be activated externally without modification to
         the program by setting the environment variable REXXTRACE to
         an appropriate trace setting.






                                Page [74]




                                Chapter 9.
                                Functions




      A function is a call to an internal or external routine.  Func-
      tions have a name, one or more arguments (though arguments are
      not always required), and return a single result string.

      Functions are of the form:

      ÄÂÄsymbol(ÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
         ³         ³  ³ ÚÄÄÄÄÄÄÄ,ÄÄÄÄÄÄ¿ ³
         ÀÄstring(ÄÙ  ÀÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÁÄÙ
                         ÀÄexpressionÄÙ

      REXX takes the literal string or symbol as a constant.    You can
      include a function in an expression anywhere that a literal
      string or symbol is valid.

      The expressions between the parentheses are the arguments to the
      function.  Each argument can include further function calls.  The
      value a function returns depends on the argument(s).


   Types of Functions

      You can call the following types of routines as functions:

      InternalA routine that resides in the same file as the program
              that uses it is called an internal routine, or function.
              An internal function starts at a label in the program.
              REXX saves the current state of interpretation, so that
              later it can return to the point of invocation to resume
              execution.  REXX also saves other internal values (TRACE
              and NUMERIC settings, and so forth).  See the CALL
              instruction on page 33.  If you call an internal routine
              as a function, you must specify an expression on any
              RETURN instruction you execute to return from the
              routine.  This is not necessary if you call an internal
              routine as a subroutine.

      Built-inREXX contains a useful set of built-in functions.  See
              "Built-In Functions" on page 77.

      ExternalA routine that resides in a separate file from the
              program that uses it is called an external routine, or
              function.  You can write these external routines in any
              language that supports the system dependent interfaces
              from which REXX invokes the function (including REXX).
              This means you can invoke a REXX program as a function,


                                Page [75]

              and pass it more than one argument string.  Since you
              call the program as a function, it must return data to
              the caller.

              You can use the ARG or PARSE ARG instructions to retrieve
              the argument string(s), or the ARG built-in function.

              Calling an external routine as a function is similar to
              calling an internal routine.  However, the external
              routine protects its variables from the caller's vari-
              ables and its internal values start with their defaults
              rather than inheriting the caller's internal values.
              Another difference is that you can use the EXIT instruc-
              tion to return from the routine.

      The function calling mechanism is the same as the mechanism used
      for subroutines.  However, a subroutine need not return a result,
      but a function must return a result.


   Search order

      REXX searches for functions in this order:

      1. Internal labels

      2. Built-in functions

      3. External functions

      If you specify the function name as a literal string, REXX
      bypasses the search for internal labels.  For example:

      x='FUNC1'()  /* calls an external routine */
      x=FUNC1()    /* calls an internal routine */
      exit

      /* Func1 - Internal routine  */
      FUNC1:
         say 'Internal routine'
         return 1

      Note that the built-in functions have upper case names, and so
      the name in the literal string must be in upper case for the
      search to succeed, as in the example.  The same is often true of
      external functions.


   Error recovery

      If an external or built-in function detects an error, it informs
      REXX, and issues a syntax error.    REXX stops executing the
      clause that includes the function call.  Similarly, if an
      external function fails to return data correctly, REXX issues an
      error.


                                Page [76]

      You can use SIGNAL ON SYNTAX to trap a syntax error during the
      execution of an internal function, and recovery might be possi-
      ble.  If you do not trap the error, the whole program stops
      executing in the usual way.


   Built-In Functions

      REXX contains many useful built-in functions. These functions
      perform various searching, processing, comparison, and conversion
      operations for both text and numbers.  Other built-in functions
      provide formatting capabilities and arithmetic calculations.

      Notes:

      *  The built-in functions work internally with the default
         settings NUMERIC DIGITS 9 and NUMERIC FUZZ 0.  Therefore, any
         changes to the NUMERIC instruction settings do not affect the
         built-in functions, except where stated.

      *  You can provide a null string where a string is referenced.

      *  Pad characters must be exactly one character long.

                        Table 10. Built-in Functions


                  Function             Description

                 ABBREV( )    Specifies which abbreviations
                              the program can use
                 ABS( )       Returns the absolute value of
                              a number
                 ADDRESS( )   Returns the name of the envi-
                              ronment to which host commands
                              are being submitted
                 ARG( )       Returns an argument string,
                              information about the argument
                              strings, or the number of
                              arguments provided to a
                              program or internal routine
                 BITAND( )    Returns a string composed of
                              two input strings logically
                              ANDed together
                 BITOR( )     Returns a string composed of
                              two input strings logically
                              ORed together
                 BITXOR( )    Returns a string composed of
                              two input strings logically
                              exclusive ORed together
                 B2X( )       Converts a binary string to a
                              hexadecimal value
                 CENTER( )    Centers a substring within a
                              string
                                              continued ...


                                Page [77]


                  Function             Description
                 CENTRE( )    Centers a substring within a
                              string
                 CHARIN( )    Returns a string of characters
                              read from a character input
                              stream
                 CHAROUT( )   Writes a string to a character
                              output stream
                 CHARS( )     Returns the total number of
                              characters remaining in a
                              character input stream
                 COMPARE( )   Compares two strings and finds
                              the position of the first
                              character in the first string
                              that does not match the second
                              string
                 CONDITION(   Returns the condition informa-
                 )            tion associated with the
                              current trapped condition
                 COPIES( )    Returns a number of copies of
                              a string, directly concate-
                              nated
                 C2D( )       Converts an ASCII character to
                              its value in decimal
                 C2X( )       Converts an ASCII character to
                              its value in hexadecimal
                 DATATYPE( )  Tests REXX data types such as
                              numeric, alphanumeric
                 DATE( )      Returns the local date in many
                              different formats
                 DELSTR( )    Deletes a substring from a
                              string
                 DELWORD( )   Deletes a substring from a
                              string, by word
                 DIGITS( )    Returns the current setting of
                              the NUMERIC DIGITS instruction
                 D2C( )       Converts a value in decimal to
                              an ASCII character
                 D2X( )       Converts a value in decimal to
                              a hexadecimal value
                 ERRORTEXT(   Returns the REXX error message
                 )            associated with an error
                              number
                 FORM( )      Returns the current setting of
                              the NUMERIC FORM instruction
                 FORMAT( )    Rounds and formats a number
                 FUZZ( )      Returns the current setting of
                              the NUMERIC FUZZ instruction
                 INSERT( )    Inserts a string into another
                              string
                 LASTPOS( )   Finds the position of a
                              substring in another string,
                              by scanning backwards
                                              continued ...


                                Page [78]


                  Function             Description
                 LEFT( )      Returns characters from the
                              left side of a string
                 LENGTH( )    Returns the length of a string
                 LINEIN( )    Returns a line from a
                              character input stream
                 LINEOUT( )   Writes a string to a character
                              output stream
                 LINES( )     Returns the total number of
                              complete lines remaining in a
                              character input stream
                 MAX( )       Returns the largest number
                              from the given list of numbers
                 MIN( )       Returns the smallest number
                              from the given list of numbers
                 OVERLAY( )   Overlays one string onto
                              another string
                 POS( )       Returns the position of a
                              substring in another string
                 QUEUED( )    Returns the number of lines
                              remaining in the external data
                              queue
                 RANDOM( )    Returns a number chosen at
                              random from a range of numbers
                 REVERSE( )   Reverses the order of charac-
                              ters in a string
                 RIGHT( )     Returns characters from the
                              right side of a string
                 SIGN( )      Tests a number for >, <, or =
                              to zero after rounding
                 SOURCELINE(  Returns the number of lines in
                 )            the program, or a line itself
                 SPACE( )     Formats the words in a string
                              with pad characters between
                              each word
                 STREAM( )    Returns a string that
                              describes the state of, or
                              result of an operation upon, a
                              character stream
                 STRIP( )     Removes leading or trailing
                              characters from string
                 SUBSTR( )    Returns a substring of a
                              string, by character
                 SUBWORD( )   Returns a substring of a
                              string, by word
                 SYMBOL( )    Indicates whether a symbol has
                              already been used as a name of
                              a variable
                 TIME( )      Returns the local time in many
                              different formats
                 TRACE( )     Returns the trace setting
                              currently in effect
                                              continued ...



                                Page [79]


                  Function             Description
                 TRANSLATE(   Translates characters in a
                 )            string to other characters, or
                              reorders characters in a
                              string
                 TRUNC( )     Returns the integer part of a
                              number
                 VALUE( )     Returns the value of a symbol
                 VERIFY( )    Verifies whether a character
                              string is, or is not, a member
                              of a given character set
                 WORD( )      Returns the nth blank-
                              delimited word in string
                 WORDINDEX(   Returns the character position
                 )            of a word in a string
                 WORDLENGTH(  Returns the length of a word
                 )            in a string
                 WORDPOS( )   Searches a string for a
                              phrase, and returns the number
                              of the first word in the
                              phrase
                 WORDS( )     Returns the number of blank-
                              delimited words in a string
                 XRANGE( )    Returns a string of one byte
                              character representations
                              within a range of characters
                 X2B( )       Converts a value in
                              hexadecimal to a binary string
                 X2C( )       Converts a value in
                              hexadecimal to an ASCII char-
                              acter
                 X2D( )       Converts a value in
                              hexadecimal to a decimal value


   Word Functions

                          Table 11. Word Functions


                  Function             Description

                 DELWORD( )   Deletes a substring from a
                              string, by word
                 SPACE( )     Formats the words in a string
                              with pad characters between
                              each word
                 SUBWORD( )   Returns a substring of a
                              string, by word
                 WORD( )      Returns the nth blank-
                              delimited word in string
                 WORDINDEX(   Returns the character position
                 )            of a word in a string
                                              continued ...


                                Page [80]


                  Function             Description
                 WORDLENGTH(  Returns the length of a word
                 )            in a string
                 WORDPOS( )   Searches a string for a
                              phrase, and returns the number
                              of the first word in the
                              phrase
                 WORDS( )     Returns the number of blank-
                              delimited words in a string


   String Functions

                         Table 12. String Functions


                  Function             Description

                 ABBREV( )    Specifies which abbreviations
                              the program can use
                 BITAND( )    Returns a string composed of
                              two input strings logically
                              ANDed together
                 BITOR( )     Returns a string composed of
                              two input strings logically
                              ORed together
                 BITXOR( )    Returns a string composed of
                              two input strings logically
                              exclusive ORed together
                 CENTER( )    Centers a string within a
                              length
                 CENTRE( )    Centers a string within a
                              length
                 COMPARE( )   Compares two strings and finds
                              the position of the first
                              character in the first
                 COPIES( )    Returns a number of copies of
                              a string, directly concate-
                              nated
                 DELSTR( )    Deletes a substring from a
                              string
                 INSERT( )    Inserts a string into another
                              string
                 LASTPOS( )   Finds the position of a
                              substring in another string,
                              by scanning backwards
                 LEFT( )      Returns characters from the
                              left side of a string
                 LENGTH( )    Returns the length of a string
                 OVERLAY( )   Overlays one string onto
                              another string
                 POS( )       Returns the position of a
                              substring in another string
                                              continued ...


                                Page [81]


                  Function             Description
                 REVERSE( )   Reverses the order of charac-
                              ters in a string
                 RIGHT( )     Returns characters from the
                              right side of a string
                 SPACE( )     Formats the words in a string
                              with pad characters between
                              each word
                 STRIP( )     Removes leading/trailing char-
                              acters from string
                 SUBSTR( )    Returns a substring of a
                              string, by character
                 TRANSLATE(   Translates characters in a
                 )            string to other characters, or
                              reorders characters in a
                              string
                 VERIFY( )    Verifies whether a character
                              string is, or is not, a member
                              of a given character set
                 XRANGE( )    Returns a string of one byte
                              character representations
                              within a range of characters


   Conversion Functions

                       Table 13. Conversion Functions


                  Function             Description

                 B2X( )       Converts a binary string to a
                              value in hexadecimal
                 C2D( )       Converts an ASCII character to
                              its value in decimal
                 C2X( )       Converts an ASCII character to
                              its value in hexadecimal
                 D2C( )       Converts a value in decimal to
                              an ASCII character
                 D2X( )       Converts a value in decimal to
                              a hexadecimal value
                 FORMAT( )    Rounds and formats a number
                 TRUNC( )     Returns the integer part of a
                              number
                 X2B( )       Converts a value in
                              hexadecimal to a binary string
                 X2C( )       Converts a value in
                              hexadecimal to an ASCII char-
                              acter
                 X2D( )       Converts a value in
                              hexadecimal to a decimal value


   Math Functions


                                Page [82]

                          Table 14. Math Functions


                  Function             Description

                 ABS( )       Returns the absolute value of
                              a number
                 DIGITS( )    Returns the current setting of
                              the NUMERIC DIGITS instruction
                 FORM( )      Returns the current setting of
                              the NUMERIC FORM instruction
                 FUZZ( )      Returns the current setting of
                              the NUMERIC FUZZ instruction
                 MAX( )       Returns the largest number
                              from the given list of numbers
                 MIN( )       Returns the smallest number
                              from the given list of numbers
                 RANDOM( )    Returns a number chosen at
                              random from a range of numbers
                 SIGN( )      Tests a number for >, <, or =
                              to zero after rounding
                 TRUNC( )     Returns the integer part of a
                              number


   I/O Functions

                           Table 15. I/O Functions


                  Function             Description

                 CHARIN( )    Returns a string of characters
                              read from a character input
                              stream
                 CHAROUT( )   Writes a string to a character
                              output stream
                 CHARS( )     Returns the total number of
                              characters remaining in a
                              character input stream
                 LINEIN( )    Returns a line from a
                              character input stream
                 LINEOUT( )   Writes a string to a character
                              output stream
                 LINES( )     Returns the total number of
                              complete lines remaining in a
                              character input stream
                 STREAM( )    Returns a string that
                              describes the state of, or
                              results of an operation upon,
                              a character stream.


   Information Functions

                       Table 16. Information Functions

                                Page [83]


                  Function             Description

                 CONDITION(   Returns the condition informa-
                 )            tion associated with the
                              current trapped condition
                 DATATYPE( )  Tests REXX data types such as
                              numeric, alphanumeric
                 DATE( )      Returns the local date in many
                              different formats
                 ERRORTEXT(   Returns the REXX error message
                 )            associated with an error
                              number
                 QUEUED( )    Returns the number of lines
                              remaining in the external data
                              queue
                 SOURCELINE(  Returns the number of lines in
                 )            the program, or a line itself
                 SYMBOL( )    Indicates whether a symbol has
                              already been used as a name of
                              a variable
                 TIME( )      Returns the local time in many
                              different formats
                 TRACE( )     Returns the trace setting
                              currently in effect
                 VALUE( )     Returns the value of a symbol































                                Page [84]

   --------------------------------------------------------------------
                                  ABBREV
   --------------------------------------------------------------------


   Purpose

      Specifies which abbreviations the program will accept from the
      user.

   Syntax

      ÄABBREV(information,infoÄÂÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                 ÀÄ,lengthÄÙ

   Parameters

      information The keyword in full

      info        The user's answer

      length      The minimum number of characters in the user's
                  answer.  The default is the the length of info.
                  Length must be a nonnegative whole number.

                  A null string will always match if you use a length
                  of 0 (or the default).  This lets you select a
                  default keyword automatically.

   Remarks

      Returns 1 (true) if info is at least length characters long and
      all the characters of info match the corresponding characters of
      information.  Otherwise, returns 0 (false).

   Examples

      ABBREV('Change','Cha')    @  1
      ABBREV('CHANGE','Cha')    @  0
      ABBREV('CHANGE','Cha',4)  @  0
      ABBREV('CHANGE','CHE')    @  0
      ABBREV('CHANGE','')       @  1
      ABBREV('CHANGE','',1)     @  0














                                Page [85]

   Example

      1 say 'Enter option:'
      2 pull option .
      3 select
      4    when abbrev('OPEN',option) then ...
      5    when abbrev('CLOSE',option) then ...
      6    when abbrev('PRINT',option) then ...
      7       ...
      8    otherwise nop;
      9 end;

        4:Match on 'OPEN', 'OPE', 'OP', or 'O'
        5:Match on 'CLOSE', 'CLOS', 'CLO', 'CL', or 'C'
        6:Match on 'PRINT', 'PRIN', 'PRI', 'PR', or 'P'

   See Also

      COMPARE( )  Compares two strings

      DATATYPE( ) Checks that characters in a string are valid
                  according to some data type.

      VERIFY( )   Verifies whether a character string is, or is not,
                  part of a character set
































                                Page [86]

   --------------------------------------------------------------------
                                   ABS
   --------------------------------------------------------------------


   Purpose

      Returns the absolute value of a number.  The result has no sign
      and is formatted according to the current NUMERIC instruction
      settings.

   Syntax

      ÄABS(number)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      number The number to evaluate

   Examples

      ABS('123.45')       @  123.45
      ABS(' -0.333')      @  0.333
      ABS('-1.0E1')       @  10

   See Also

      SIGN( )     Tests a number for <, >, or = to zero after rounding





























                                Page [87]

   --------------------------------------------------------------------
                                 ADDRESS
   --------------------------------------------------------------------


   Purpose

      Returns the name of the environment to which host commands are
      currently being submitted.  See the ADDRESS instruction on page
      29.

   Syntax

      ÄADDRESS()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Examples

      ADDRESS( )         @  'CMD'
      ADDRESS( )         @  'SPF2'






































                                Page [88]

   --------------------------------------------------------------------
                                   ARG
   --------------------------------------------------------------------


   Purpose

      Returns an argument string, information about the argument
      strings, or the number of arguments provided to a program or
      internal routine.

   Syntax

      ÄARG(ÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
              ÀÄnÄÂÄÄÄÄÄÄÄÄÄÂÙ
                  ÀÄ,optionÄÙ

   Parameters

      If you leave out the arguments, ARG returns the number of argu-
      ment strings passed to the program or internal routine.

      n      The number of the argument string to return.  If the argu-
             ment string does not exist, returns the null string.  N
             must be positive.

      option Tests for the existence of the nth argument string.  The
             options are:

             E  (Exists) Returns 1 if the nth argument exists; that is,
                if it was explicitly specified when the routine was
                invoked.  Returns 0 otherwise.

             O  (Omitted) Returns 1 if the nth argument was omitted;
                that is, if it was not explicitly specified when the
                routine was invoked.  Returns 0 otherwise.

   Examples

      1 /* Following "Call name;"  (no arguments)  */
      2 ARG( )      @  0
      3 ARG(1)      @  ''
      4 ARG(2)      @  ''
      5 ARG(1,'e')  @  0
      6 ARG(1,'o')  @  1

        2:Number of arguments is 0
        3:Argument string 1 is ''
        4:Argument string 2 is ''
        5:Argument string 1 does not exist
        6:Argument string 1 was omitted






                                Page [89]

   Examples

      1 /* Following "Call name 1,,2;" */
      2 ARG( )      @  3
      3 ARG(1)      @  1
      4 ARG(2)      @  ''
      5 ARG(3)      @  2
      6 ARG(8)      @  ''
      7 ARG(1,'e')  @  1
      8 ARG(2,'E')  @  0
      9 ARG(2,'O')  @  1
      10ARG(3,'o')  @  0
      11ARG(4,'o')  @  1

        2:Number of argument is 3
        3:Argument string 1 is '1'
        4:Argument string 2 is ''
        5:Argument string 3 is '2'
        6:Argument string 8 is ''
        7:Argument string 1 exists
        8:Argument string 2 does not exist
        9:Argument string 2 was omitted
        10:Argument string 3 was not omitted
        11:Argument string 4 was omitted

   Remarks

      1. To retrieve and parse the argument strings passed to a
         program, use the ARG or PARSE ARG instructions.

      2. Programs called as commands can only have 0 or 1 argument
         strings.

























                                Page [90]

   --------------------------------------------------------------------
                                  BITAND
   --------------------------------------------------------------------


   Purpose

      Returns a string composed of the two input strings logically
      ANDed together, bit by bit.  The length of the result is the
      length of the longer of the two strings.

   Syntax

      ÄBITAND(string1ÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                        ÀÄ,ÄÂÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÂÙ
                            ÀÄstring2ÄÙ ÀÄ,padÄÙ

   Parameters

      string1  The first string

      string2  The second string.  The default is the null string.

      pad      The pad character to use to extend the shorter of the
               two strings on the right, before carrying out the
               logical operation.  If you do not provide a pad charac-
               ter, the AND operation terminates when the shorter of
               the two strings is exhausted.  It then appends the
               unprocessed portion of the longer string to the partial
               result.

   Examples

      BITAND('53'x,'6F'x)          @  '43'x
      BITAND('1A'x,'5C5C'x)        @  '185C'x
      BITAND('1A'x,'5C5C'x,'0F'X)  @  '180C'x
      BITAND('abcd',,'4F'x)        @  'ABCD'

   See Also

      BITOR( )    Returns a string composed of two input strings
                  logically ORed together

      BITXOR( )   Returns a string composed of two input strings
                  logically exclusive ORed together












                                Page [91]

   --------------------------------------------------------------------
                                  BITOR
   --------------------------------------------------------------------


   Purpose

      Returns a string composed of the two input strings logically
      (inclusively) ORed together, bit by bit.  The length of the
      result is the length of the longer of the two strings.

   Syntax

      ÄBITOR(string1ÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                       ÀÄ,ÄÂÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÂÙ
                           ÀÄstring2ÄÙ ÀÄ,padÄÙ

   Parameters

      string1  The first string

      string2  The second string.  The default is the null string.

      pad      The pad character to use to extend the shorter of the
               two strings on the right, before carrying out the
               logical operation.  If you do not provide a pad charac-
               ter, the OR operation terminates when the shorter of the
               two strings is exhausted.  It then appends the unpro-
               cessed portion of the longer string to the partial
               result.

   Examples

      BITOR('6C'x,'31'x)          @  '7D'x
      BITOR('6C'x,'5A5A'x)        @  '7E5A'x
      BITOR('6C'x,'5A5A'x,'FO'x)  @  '7EFA'x
      BITOR('1111'x,,'3C'x)       @  '3D3D'x
      BITOR('Rick',,'20'x)        @  'rick'

   See Also

      BITAND( )   Returns a string composed of two input strings
                  logically ANDed together

      BITXOR( )   Returns a string composed of two input strings
                  logically exclusive ORed together











                                Page [92]

   --------------------------------------------------------------------
                                  BITXOR
   --------------------------------------------------------------------


   Purpose

      Returns a string composed of the two input strings logically
      exclusive ORed together, bit by bit.  The length of the result is
      the length of the longer of the two strings.

   Syntax

      ÄBITXOR(string1ÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                        ÀÄ,ÄÂÄÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÂÙ
                            ÀÄstring2ÄÙ ÀÄ,padÄÙ

   Parameters

      string1  The first string

      string2  The second string.  The default is the null string.

      pad      The pad character to use to extend the shorter of the
               two strings on the right, before carrying out the
               logical operation.  If you do not provide a pad charac-
               ter, the XOR operation terminates when the shorter of
               the two strings is exhausted.  It then appends the
               unprocessed portion of the longer string to the partial
               result.

   Examples

      BITXOR('12'x,'22'x)              @  '30'x
      BITXOR('1211'x,'22'x)            @  '3011'x
      BITXOR('1211'x,'222222'x,' ')    @  '303302'x
      BITXOR('1211'x,'222222'x)        @  '303322'x
      BITXOR('1211'x,'222222'x,'20'x)  @  '303302'x
      BITXOR('1211'x,,'3A'x)           @  '282B'x
      BITXOR('1211'x,'222222'x,' ')    @  '303302'x

   See Also

      BITAND( )   Returns a string composed of two input strings
                  logically ANDed together

      BITOR( )    Returns a string composed of two input strings
                  logically ORed together









                                Page [93]

   --------------------------------------------------------------------
                                   B2X
   --------------------------------------------------------------------


   Purpose

      Converts a binary string to a hexadecimal string.

   Syntax

      ÄB2X(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameters

      string The string to convert, which can be any length.  If string
             is a null string, B2X returns a null string.

   Remarks

      The returned string uses uppercase alphabetics for the values
      A-F, and does not include any blanks.

      You can optionally add blanks between groups of 8 (byte) or 4
      (nibble) digits (not leading or trailing) to aid readability;
      they are ignored.

      If necessary, B2X pads string with up to three leading zeros to
      make a multiple of four binary digits.

   Examples

      B2X('1010010')         @  '52'x
      B2X('01010010')        @  '52'x
      B2X('0101 0010')       @  '52'x
      B2X('0101 0010 1111')  @  '52F'x

   See Also

      C2D( )      Converts an ASCII character to its value in decimal

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2C( )      Converts a value in decimal to an ASCII character

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2B( )      Converts a hexadecimal value to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character

      X2D( )      Converts a value in hexadecimal to a decimal value




                                Page [94]

   --------------------------------------------------------------------
                                  CENTER
   --------------------------------------------------------------------


   Purpose

      Centers a substring within a string.

   Syntax

      ÄÂÄCENTER(ÄÂÄstring,lengthÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
         ³         ³               ³      ³
         ÀÄCENTRE(ÄÙ               ÀÄ,padÄÙ

   Parameters

      string The substring to center

      length The length of the string in which string is centered.
             length must be zero or positive.  If the substring to
             center is longer than length, CENTER truncates it at both
             ends to fit.  If an odd number of characters are added,
             CENTER puts the extra character on the right of the
             string.  If an odd number of characters are deleted,
             CENTER deletes the extra character on the right of the
             string.

      pad    The pad character to use to fill the required length.  The
             default pad character is blank.

   Examples

      CENTER(cat,5)              @  ' CAT '
      CENTER(cat,9,'-')          @  '---CAT---'
      CENTER('The plus sign',8)  @  'e plus s'
      CENTER('The plus sign',7)  @  ' plus s'

      Note:  You can call this function either CENTRE or CENTER, to
      accommodate British and American spellings.

   See Also

      LEFT( )     Returns characters from the left side of a string

      RIGHT( )    Returns characters from the right side of a string

      SPACE( )    Formats the words in a string with pad characters
                  between each word








                                Page [95]

   --------------------------------------------------------------------
                                  CHARIN
   --------------------------------------------------------------------


   Purpose

      Returns a string of characters read from a character input
      stream.

   Syntax

      ÄCHARIN(ÄÂÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄÄ
                 ÀÄnameÄÙ ÀÄ,ÄÂÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÂÄÙ
                              ÀÄstartÄÙÀÄ,lengthÄÙ

   Parameters

      name   The file name, which can be any system file.  The file
             name can include drive and path specifications.  If you
             omit name, CHARIN reads characters from the default input
             stream.

      start  The explicit read position for the read to start.  start
             must be positive and within the bounds of the stream.  A
             value of 1 specifies the first character in the stream.
             The default is the current read position.  When CHARIN
             completes the read, it increases the read position by the
             number of characters read.

             For persistent streams (for example, files and objects),
             REXX maintains a read position for each stream.  Any read
             from the stream starts at the position by the number of
             characters read.  You cannot specify a read position for a
             transient stream; for example, data sent or received over
             a serial interface.

      length The number of characters in the string.  The default is 1.
             If you specify a length of 0, REXX sets the read position
             to the value of start, but does not read any characters
             and returns the null string.

             If there are fewer than length characters available,
             program execution stops until sufficient characters do
             become available.  If, however, it is impossible for those
             characters to become available, CHARIN returns with fewer
             than the requested number of characters.










                                Page [96]

   Examples

      1 CHARIN(infile,1,3)  @  'CTC'
      2 CHARIN(infile,1,0)  @  ''
      3 CHARIN(infile)      @  'C'
      4 CHARIN(infile,,2)   @  'TC'
      5 CHARIN( )           @  'a'
      6 CHARIN(,,3)         @  'bcd'

        1:Reads characters 1 to 3
        2:Returns to start
        3:Reads 1 character
        4:Reads 2 more characters
        5:Uses the default stream
        6:Reads 3 more characters

   See Also

      CHAROUT( )  Writes a string to a character output stream

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream

























                                Page [97]

   --------------------------------------------------------------------
                                 CHAROUT
   --------------------------------------------------------------------


   Purpose

      Writes a string of characters to a character output stream.

   Syntax

      ÄCHAROUT(ÄÂÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ)ÄÄÄÄÄÄÄÄÄ
                  ÀÄnameÄÙ ÀÄ,ÄÂÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÂÄÙ
                               ÀÄstartÄÙÀÄ,lengthÄÙ

   Parameters

      name   The name of the output device, which is usually a file
             name.  The file name can include drive and path specifica-
             tions.  If you omit name, REXX writes the character string
             to the default output stream.

      string The string to write.  You can specify the null string, in
             which case REXX does not write any characters to the
             stream and always returns 0.  You can omit this argument
             for persistent streams.  In this case, CHAROUT sets the
             write position to the value of start, does not write any
             characters to the stream, and returns 0.

      start  The explicit position for the write to start.  The start
             value must be positive and within the bounds of the
             stream, although it can specify the character position
             immediately after the end of the stream.  A value of 1
             specifies the first character in the stream.  The default
             is to start at the current write position.

   Remarks

      For persistent streams, CHAROUT maintains a write position for
      each stream.  When CHAROUT completes the write, it increases the
      write position by the number of characters written.  The initial
      write position is the end of the stream, so that calls to CHAROUT
      normally append to the end of the stream.  (Unless the stream was
      opened using the STREAM() function.)

      If you do not specify a start position or a string, CHAROUT sets
      the write position to the end of the stream, closes the file, and
      returns 0.

      The program stops executing until the output operation is effec-
      tively complete.  If, however, CHAROUT cannot write all the char-
      acters, it returns with the number of characters that could not
      be written (the residual count).




                                Page [98]

   Examples

      1 CHAROUT(outfile,'At')    @ 0
      2 CHAROUT(outfile,'At',4)  @ 0
      3 CHAROUT(outfile,,5)      @ 0
      4 CHAROUT('PRN','At')      @ 0
      5 CHAROUT('LPT1')          @ 0
      6 CHAROUT(,'At')           @ 0
      7 CHAROUT(,'Think')        @ 2

        1:Indicates a normal return
        2:Indicates a normal return
        3:Sets current file position to character 5
        4:Writes the string 'At' to the default print device (PRN)
        5:Writes the string 'At' to printer LPT1
        6:Indicates a normal return
        7:Indicates 2 characters left

   Examples

      This routine is best called as a subroutine.  The residual count
      is then available in the special variable RESULT.

      Call CHAROUT outfile, 'Think'
      Call CHAROUT outfile, 'At',5
      Call CHAROUT outfile

   See Also

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream













                                Page [99]

   --------------------------------------------------------------------
                                  CHARS
   --------------------------------------------------------------------


   Purpose

      Returns the total number of characters remaining in a character
      input stream.

   Syntax

      ÄCHARS(ÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                ÀÄnameÄÙ

   Parameter

      name   The file name, which can be any system file name,
             including specific device names.  If you omit name, CHARS
             returns the number of characters available in the default
             input stream.

   Remarks

      The count includes any line separator characters.  For persistent
      streams (for example, files), the count includes characters from
      the current read position.

      If CHARS cannot determine the count accurately or efficiently, it
      might return 1 or more for any nonzero result.

   Examples

      CHARS('c:\config.sys')  @  1381
      CHARS(nonfile)          @  0
      CHARS( )                @  12

   See Also

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream




                                Page [100]

   --------------------------------------------------------------------
                                 COMPARE
   --------------------------------------------------------------------


   Purpose

      Compares two strings and finds the position of the first
      character in the first string that does not match the second
      string.

   Syntax

      ÄABBREV(string1,string2ÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                ÀÄ,padÄÙ

   Parameters

      string1  The first string

      string2  The second string

      pad      The pad character to use to pad the shorter string on
               the right.  The default is a blank.

   Remarks

      Returns 0 if string1 and string2 are identical.  If they are not,
      COMPARE returns a positive number that indicates the position of
      the first character that is not the same in both.

   Examples

      COMPARE('look','look')     @  0
      COMPARE('look','like')     @  2
      COMPARE('at ','at')        @  0
      COMPARE('at ','at',' ')    @  0
      COMPARE('at ','at','x')    @  3
      COMPARE('at-- ','at','-')  @  5

   See Also

      ABBREV( )   Specifies which abbreviations the program will accept

      DATATYPE( ) Checks that characters in a string are valid
                  according to some data type.

      VERIFY( )   Verifies whether a character string is, or is not,
                  part of a character set








                                Page [101]

   --------------------------------------------------------------------
                                CONDITION
   --------------------------------------------------------------------


   Purpose

      Returns the condition information associated with the current
      trapped condition.  See the SIGNAL instruction on page 68 and
      "Condition Traps" on page 197.

   Syntax

      ÄCONDITION(ÄÂÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                    ÀÄoptionÄÙ

   Parameter

      option Returns four types of information:

             C  (Condition name) The name of the current trapped condi-
                tion.

             D  (Description) Any descriptive string associated with
                the current trapped condition.  If no description is
                available, CONDITION returns a null string.

             I  (Instruction) The instruction that was executed when
                the current condition was trapped, which can be either
                CALL or SIGNAL.  This is the default.

             S  (Status) The status of the current trapped condition.
                The status can change during execution.  The status is
                either ON (the condition is enabled), OFF (the condi-
                tion is disabled), or DELAY (any new occurrence of the
                condition is delayed).

   Remarks

      If there is no current trapped condition, CONDITION returns a
      null string in all four cases.

   Examples

      CONDITION( )        @  'CALL'
      CONDITION('C')      @  'FAILURE'
      CONDITION('S')      @  'OFF'

   Remarks

      REXX saves any condition information returned by CONDITION and
      restores it across subroutine calls (including those caused by a
      CALL ON condition trap).  Therefore, once a subroutine invoked by
      a CALL on trap returns, the current trapped condition reverts to
      the current condition before the CALL took place.  CONDITION
      returns the values it returned before the condition was trapped.

                                Page [102]


























































                                Page [103]

   --------------------------------------------------------------------
                                  COPIES
   --------------------------------------------------------------------


   Purpose

      Produces a number of copies of a string, directly concatenated.

   Syntax

      ÄCOPIES(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameters

      string The string to copy

      n      The number of copies, which must be a non-negative whole
             number.

   Examples

      COPIES('xyz',3)     @  'xyzxyzxyz'
      COPIES('dxv',0)     @  ''

   See Also

      SUBSTR( )   Returns a substring of a string, by character





























                                Page [104]

   --------------------------------------------------------------------
                                   C2D
   --------------------------------------------------------------------


   Purpose

      Converts character to decimal.

   Syntax

      ÄC2D(stringÄÂÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                    ÀÄ,nÄÙ

   Parameters

      string The string to convert.  String can be the null string, in
             which case C2D returns 0.

      n      Specifies that the binary string of the string is taken to
             be a two's complement number expressed in n characters,
             and is converted to a whole number which might therefore
             be negative.  If n is 0, C2D always returns 0.  If n is
             not specified, string is taken to be an unsigned number.

   Remarks

      Returns the decimal value of the binary representation of string.
      If the result cannot be expressed as a whole number, an error
      results.  That is, the result must not have more digits than the
      current setting of NUMERIC DIGITS.

      C2D pads the string on the left with the characters '00'X (note,
      not "sign-extended") or truncates the string on the left to the
      length n characters, if necessary.  This is as though
      RIGHT(string,n,'00'x) had been executed.

   Examples

      C2D('09'x)          @      9
      C2D('81'x)          @    129
      C2D('a')            @     97
      C2D('FF81'x)        @  65409
      C2D('')             @      0
      C2D('81'x,1         @   -127
      C2D('81'x,2)        @    129
      C2D('FF81'x,2)      @   -127
      C2D('FF81'x,1)      @   -127
      C2D('FF7F'x,1)      @    127
      C2D('F081'x,2)      @  -3967
      C2D('F081'x,1)      @   -127
      C2D('0031'x,0)      @      0





                                Page [105]

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2C( )      Converts a value in decimal to an ASCII character

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2B( )      Converts a hexadecimal value to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character

      X2D( )      Converts a value in hexadecimal to a decimal value









































                                Page [106]

   --------------------------------------------------------------------
                                   C2X
   --------------------------------------------------------------------


   Purpose

      Converts character to hexadecimal (unpacks).

   Syntax

      ÄC2X(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      string The string to convert, which can be any length

   Remarks

      The returned string uses uppercase alphabetics for the values
      A-F, and does not include any blanks.

   Examples

      C2X('JKL')          @  '6A6B6C'
      C2X('1234'x)        @  '1234'

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2D( )      Converts an ASCII character to its value in decimal

      D2C( )      Converts a value in decimal to an ASCII character

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2B( )      Converts a hexadecimal value to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character

      X2D( )      Converts a value in hexadecimal to a decimal value















                                Page [107]

   --------------------------------------------------------------------
                                 DATATYPE
   --------------------------------------------------------------------


   Purpose

      Checks that data is valid.  This is useful to check data before
      attempting to do arithmetic on data entered from the keyboard.

   Syntax

      ÄDATATYPE(stringÄÂÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                         ÀÄ,typeÄÙ

   Parameters

      string The data to check.  Returns NUM if string is a valid REXX
             number (any format).  Otherwise, it returns the word CHAR.

      type   The type of data to match.  Returns 1 if string matches
             the type, or 0 otherwise.  If string is null, DATATYPE
             returns 0 (except when type is "X", which returns 1 for a
             null string).  The options are:

             A  (Alphanumeric) Returns 1 if string only contains char-
                acters from the ranges "a-z", "A-Z", and "0-9".

             B  (Bits) Returns 1 if string only contains the characters
                "0" and/or "1".

             L  (Lower case) Returns 1 if string only contains charac-
                ters from the range "a-z".

             M  (Mixed case) Returns 1 if string only contains charac-
                ters from the ranges "a-z" and "A-Z".

             N  (Number) Returns 1 if string is a valid REXX number.

             S  (Symbol) Returns 1 if string only contains characters
                that are valid in REXX symbols.    Lower case
                alphabetics are permitted.

             U  (Upper case) Returns 1 if string only contains charac-
                ters from the range "A-Z".

             W  (Whole number) Returns 1 if string is a REXX whole
                number under the current setting of the NUMERIC DIGITS
                instruction.

             X  (heXadecimal) Returns 1 if string only contains charac-
                ters from the ranges "a-f", "A-F", "0-9", and blank (so
                long as blanks only appear between pairs of hexadecimal
                characters, as usual.) Also returns 1 if string is a
                null string, which is a valid hexadecimal string.


                                Page [108]

   Examples

      DATATYPE(' 23 ')       @  'NUM'
      DATATYPE(' ')          @  'CHAR'
      DATATYPE('123*')       @  'CHAR
      DATATYPE('Minx','L')   @  0
      DATATYPE('Fred','M')   @  1
      DATATYPE('','M')       @  0
      DATATYPE('12.3','N')   @  1
      DATATYPE('$10k','S')   @  1
      DATATYPE('12','W')     @  1
      DATATYPE('12.3','W')   @  0
      DATATYPE('CF3A','X')   @  1
      DATATYPE('CF 3A','X')  @  1

   See Also

      COMPARE( )  Compares two strings

      TRANSLATE( )Translates characters in a string

      VERIFY( )   Verifies whether a character string is, or is not,
                  part of a character set


































                                Page [109]

   --------------------------------------------------------------------
                                   DATE
   --------------------------------------------------------------------


   Purpose

      Returns the local date in the format 'dd mmm yyyy' (for example,
      '22 Apr 1989'), with no leading zero or blank on the day.

   Syntax

      ÄDATE(ÄÂÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
               ÀÄoptionÄÙ

   Parameter

      option The format to use to return the date.  The options are:

             B  (Basedate) Returns the number of complete days (not
                including the current day) since and including the base
                date, January 1, 0001, in the format:  dddddd (no
                leading zeros).  The expression "DATE(B)//7" returns a
                number in the range 0-6, where 0 is Monday and 6 is
                Sunday.

                You can use this option to determine the day of the
                week independent of the national language in which you
                are working.

                Note: The origin of January 1, 0001 is based on the
                Gregorian calendar.  Though this calendar did not exist
                prior to 1582, Basedate is calculated as if it did:
                365 days per year, an extra day every four years except
                century years, and leap centuries if the century is
                divisible by 400.  It does not take into account any
                errors in the calendar system that created the Grego-
                rian calendar originally.

             C  (Century) Returns the number of days, including the
                current day, so far in this century in the format
                'ddddd' (no leading zeros or blanks).

             D  (Days) Returns the number of days, including the
                current day, so far in this year in the format 'ddd'
                (no leading zeros or blanks).

             E  (European) Returns the date in the format 'dd/mm/yy'.

             J  (Julian) Returns the date in the format 'yyddd', where
                'ddd' is the number of days so far in the year.

             L  (Language) Returns the date in the format
                'dd month yyy'.



                                Page [110]

             M  (Month) Returns the full name of the current month, in
                mixed case.

             N  (Normal) Explicitly returns the date in the default
                format 'dd mmm yyyy', as described above.

             O  (Ordered) Returns the date in the format 'yy/mm/dd'
                (suitable for sorting).

             S  (Standard) Returns date in the format 'yyyymmdd' (suit-
                able for sorting).  This is one of the three forms
                recommended in the International Standards Organization
                Recommendation ISO/R 2014-1971 (E).  The other two
                forms that document recommends can be derived from this
                form by separating the month from the year and day
                using either blanks or hyphens, for example:'1989 08
                27' or '1989-08-27'.

             U  (USA) Returns the date in the format 'mm/dd/yy'.

             W  (Weekday) Returns the day of the week, in mixed case.

   Examples

      DATE( )             @  '23 Mar 1989'
      DATE('B')           @  726183
      DATE('C')           @  32589
      DATE('D')           @  82
      DATE('E')           @  '23/03/89'
      DATE('J')           @  '89082'
      DATE('L')           @  '23 March 1989'
      DATE('M')           @  'March'
      DATE('N')           @  '23 Mar 1989'
      DATE('O')           @  '89/03/23'
      DATE('S')           @  '19890323'
      DATE('U')           @  '03/23/89'
      DATE('w')           @  'Thursday'

      Note:  The first call to DATE in a clause makes a time stamp,
      which REXX then uses for all calls to DATE or TIME within that
      clause.  This guarantees consistency among multiple calls made to
      DATE or TIME in a single expression or clause.

   See Also

      TIME( )     Returns the local time in many different formats











                                Page [111]

   --------------------------------------------------------------------
                                  DELSTR
   --------------------------------------------------------------------


   Purpose

      Deletes a substring from a string, by character.

   Syntax

      ÄDELSTR(string,nÄÂÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                         ÀÄ,lengthÄÙ

   Parameters

      string The string from which to delete the substring

      n      The number of the character that determines the start of
             the substring.  N  must be a positive number.  If n is
             greater than the length of string, DELSTR returns the
             string unchanged.

      length The length of the substring.  If you do not specify
             length, DELSTR deletes the rest of the string (including
             the nth character).  Length must be a non-negative whole
             number.

   Examples

      DELSTR('jean',3)     @  'je'
      DELSTR('jeanl',3,2)  @  'jel'
      DELSTR('jeanl',6)    @  'jeanl'

   See Also

      DELWORD( )  Deletes a substring from a string, by word

      INSERT( )   Inserts a string into another string

      SUBSTR( )   Returns a substring of a string, by character

      SUBWORD( )  Returns a substring of a string, by word














                                Page [112]

   --------------------------------------------------------------------
                                 DELWORD
   --------------------------------------------------------------------


   Purpose

      Deletes a substring of a string, by word.

   Syntax

      ÄDELWORD(string,nÄÂÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                          ÀÄ,lengthÄÙ

   Parameters

      string The string from which to delete the substring

      n      The number of the word that determines the start of the
             substring.  N must be positive.  If n  is greater than the
             number of words in string, DELWORD returns the string
             unchanged.

      length The length of the substring in words, delimited by blanks.
             If you do not specify length, the default is to delete the
             remaining words in the string (including the nth word).
             Length must be a non-negative whole number.

   Remarks

      DELWORD deletes any blanks that follow the final word in the
      substring, but does not delete any blanks that precede the first
      word.

   Examples

      DELWORD('This',1)                 @  ''
      DELWORD('This is the  life',2,2)  @  'This life'
      DELWORD('This is the life',3)     @  'This is '
      DELWORD('This life',5)            @  'This life'

   See Also

      DELSTR( )   Deletes a substring from a string, by character

      INSERT( )   Inserts a string into another string

      SUBSTR( )   Returns a substring of a string, by character

      SUBWORD( )  Returns a substring of a string, by word







                                Page [113]

   --------------------------------------------------------------------
                                  DIGITS
   --------------------------------------------------------------------


   Purpose

      Returns the current setting of the NUMERIC DIGITS instruction.
      See the NUMERIC instruction on page 52.

   Syntax

      ÄDIGITS()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Example

      DIGITS( )           @  9 /* the default */

   See Also

      FORM( )     Returns the current setting of the NUMERIC FORM
                  instruction

      FORMAT( )   Rounds and formats a number

      FUZZ( )     Returns the current setting of the NUMERIC FUZZ
                  instruction






























                                Page [114]

   --------------------------------------------------------------------
                                   D2C
   --------------------------------------------------------------------


   Purpose

      Converts decimal to character.

   Syntax

      ÄD2C(whole-numberÄÂÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                          ÀÄ,nÄÙ

   Parameters

      whole-numberThe whole number to convert.

      n           The length of the final result in characters, which
                  must be a non-negative whole number.  After conver-
                  sion, D2C sign-extends the number to this length.  If
                  the number is too big to fit into n characters, D2C
                  truncates the number on the left.  If you do not
                  specify n, whole-number must be a non-negative whole
                  number, or an error will result.

   Remarks

      Returns a character string of length as needed, or of length n,
      which is the binary representation of the decimal number.  If n
      is not specified, the length of the result returned is such that
      there are no leading '00' x characters.

   Examples

      D2C(65)             @  'A'
      D2C(66)             @  'B'
      D2C(66)             @  '42'x
      D2C(127)            @  '81'x
      D2C(127,1)          @  '81'x
      D2C(127,2)          @  '0081'x
      D2C(257,1)          @  '01'x
      D2C(-127,1)         @  '81'x
      D2C(-127,2)         @  'FF81'x
      D2C(-1,4)           @  'FFFFFFFF'x
      D2C(12,0)           @  ''











                                Page [115]

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2D( )      Converts an ASCII character to its value in decimal

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2B( )      Converts a value in hexadecimal to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character

      X2D( )      Converts a value in hexadecimal to a decimal value









































                                Page [116]

   --------------------------------------------------------------------
                                   D2X
   --------------------------------------------------------------------


   Purpose

      Converts decimal to hexadecimal.

   Syntax

      ÄD2X(whole-numberÄÂÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                          ÀÄ,nÄÙ

   Parameters

      whole-numberThe whole number to convert.

      n           The length of the final result in characters, which
                  must be a non-negative whole number.  If you do not
                  specify n, whole-number must be a non-negative whole
                  number, or an error will result.  After conversion,
                  D2C sign-extends the number to this length.  If the
                  number is too big to fit into n characters, D2C trun-
                  cates the number on the left.

   Remarks

      Returns a string of hexadecimal characters of length as needed or
      of length n, which is the hexadecimal (unpacked) representation
      of the decimal number.  The returned string uses uppercase alpha-
      betics for the values A-F, and does not include any blanks.

      If you do not specify n, the length of the result returned is
      such that there are no leading '0' characters.

   Examples

      D2X(9)              @  '9'
      D2X(48)             @  '30'
      D2X(49)             @  '31'
      D2X(129)            @  '81'
      D2X(129,1)          @  '1'
      D2X(129,2)          @  '81'
      D2X(129,4)          @  '0081'
      D2X(257,2)          @  '01'
      D2X(-127,2)         @  '81'
      D2X(-127,4)         @  'FF81'
      D2X(12,0)           @  ''








                                Page [117]

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2D( )      Converts an ASCII character to its value in decimal

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2C( )      Converts a value in decimal to an ASCII character

      X2B( )      Converts a value in hexadecimal to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character

      X2D( )      Converts a value in hexadecimal to a decimal value

      Note: A call to D2X is similar to a call to D2C followed by a
      call to C2X, except that D2X can return an odd number of charac-
      ters.





































                                Page [118]

   --------------------------------------------------------------------
                                ERRORTEXT
   --------------------------------------------------------------------


   Purpose

      Returns the REXX error message associated with an error number.

   Syntax

      ÄERRORTEXT(n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      n      The error number, which must be in the range of 0-99.  Any
             other value is an error.  If n is in the allowed range,
             but is not a defined REXX error number, ERRORTEXT returns
             the null string.    See "Messages" on page 202.

   Examples

      ERRORTEXT(20)       @  'Symbol expected'
      ERRORTEXT(60)       @  ''

   See Also

      SOURCELINE( )Returns the number of lines in the program, or  n
                  lines.

      CONDITION( )Returns the condition information about the currently
                  trapped condition.

























                                Page [119]

   --------------------------------------------------------------------
                                   FORM
   --------------------------------------------------------------------


   Purpose

      Returns the current setting of the NUMERIC FORM instruction.  See
      the NUMERIC instruction on page 52.

   Syntax

      ÄFORM()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Example

      FORM( )             @  'SCIENTIFIC'

   See Also

      DIGITS( )   Returns the current setting of the NUMERIC DIGITS
                  instruction

      FORMAT( )   Rounds and formats a number

      FUZZ( )     Returns the current setting of the NUMERIC FUZZ
                  instruction






























                                Page [120]

   --------------------------------------------------------------------
                                  FORMAT
   --------------------------------------------------------------------


   Purpose

      Rounds and formats a number.  For example, you could use this
      function to align the decimal places in figures so that the
      figures align into columns, or to round numbers at a specific
      point in your calculations.

   Syntax

      ÄFORMAT(numberÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄ
                      À,ÂÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÙ
                        ÀbeforeÙÀ,ÂÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÙ
                                  ÀafterÙÀ,ÂÄÄÄÄÂÂÄÄÄÄÄÂÙ
                                           ÀexppÙÀ,exptÙ

   Parameters

      number The number to format.  The number is rounded and formatted
             according to standard REXX rules, just as though the oper-
             ation "number+0" had been carried out.

      before The number of character positions before the decimal
             point.  If before is not large enough to contain the
             integer part of the number, an error results.

      after  The number of character positions after the decimal point.
             If after is not the same size as the decimal part of the
             number, FORMAT rounds the number to fit, or extends the
             number with zeros.  If you specify 0, FORMAT rounds the
             number to an integer (that is, it will have no decimal
             part).

             Note:  If you do not specify either before or after,
             FORMAT uses as many characters as it needs for that part.

      expp   The number of places (digits) to use for the exponent
             part.  The default is to use as many as are needed,
             according to the setting of the NUMERIC DIGITS and NUMERIC
             FORM instructions.  If you specify 0, no exponent is
             supplied, and the number is expressed in a "simple" form
             with added zeros as necessary.  If expp is not large
             enough to contain the exponent, an error results.  If the
             exponent will be 0 and expp is non-zero, expp+2 blanks are
             supplied for the exponent part of the result.

      expt   The point at which to trigger exponential notation.  The
             default is the current setting of the NUMERIC DIGITS and
             NUMERIC FORM instructions.

             If the number of places needed for the integer or decimal
             exceeds expt or twice expt respectively, FORMAT uses expo-

                                Page [121]

             nential notation.  If you specify 0, FORMAT uses exponen-
             tial notation, unless the exponent would be 0.

   Examples

      FORMAT('3',4)             @  '   3'
      FORMAT('1.93',4,0)        @  '   2'
      FORMAT('1.93',4,3)        @  '   1.930'
      FORMAT('-.76',4,1)        @  '  -0.8'
      FORMAT('3.03',4)          @  '   3.03'
      FORMAT(' - 12.93',,4)     @  '-12.9300'
      FORMAT(' - 12.93')        @  '-12.93'
      FORMAT('0.000')           @  '0'

      Using exponential notation:

      FORMAT('12345.93',,,2,2)  @  '1.234593E+04'
      FORMAT('12345.93',,3,,0)  @  '1.235E+4'
      FORMAT('1.234593',,3,,0)  @  '1.235'
      FORMAT('123.45',,3,2,0)   @  '1.235E+02'
      FORMAT('1.2345',,3,2,0)   @  '1.235'
      FORMAT('12345.93',,,3,6)  @  '12345.93'
      FORMAT(1234567e5',,3,0)   @  '123456700000.000'

      Note: If NUMERIC FORM ENGINEERING is in effect, up to 3 digits
      might be needed for the integer part of the result (before).

   See Also

      DIGITS( )   Returns the current setting of the NUMERIC DIGITS
                  instruction

      FORM( )     Returns the current setting of the NUMERIC FORM
                  instruction

      FUZZ( )     Returns the current setting of the NUMERIC FUZZ
                  instruction




















                                Page [122]

   --------------------------------------------------------------------
                                   FUZZ
   --------------------------------------------------------------------


   Purpose

      Returns the current setting of the NUMERIC FUZZ instruction.  See
      the NUMERIC instruction on page 52.

   Syntax

      ÄFUZZ()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Example

      FUZZ( )             @  0

   See Also

      DIGITS( )   Returns the current setting of the NUMERIC DIGITS
                  instruction

      FORM( )     Returns the current setting of the NUMERIC FORM
                  instruction

      FORMAT( )   Rounds and formats a number






























                                Page [123]

   --------------------------------------------------------------------
                                  INSERT
   --------------------------------------------------------------------


   Purpose

      Inserts a string into another string.

   Syntax

      ÄINSERT(string,targetÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄ
                              À,ÂÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÙ
                                ÀÄnÄÙÀ,ÂÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÂÙ
                                       ÀÄlengthÄÙ ÀÄ,padÄÙ

   Parameters

      string The string to be inserted

      target The string in which to insert the other string

      n      The character position after which to insert string.  The
             default is 0, which inserts the string before the begin-
             ning of the target string.  n  must be a non-negative
             whole number.  If n is greater than the length of the
             target string, INSERT adds padding before the string.

      length The length of the string to be inserted.  String is padded
             on the right or truncated to the right according to this
             length.  The length must be a non-negative whole number.
             The default is the length of the insert string (string).

      pad    The character to use for padding.  The default character
             is a blank.

   Examples

      INSERT(' ' , 'abcdef' ,3)    @  'abc def'
      INSERT('123', 'abc' ,5,6)    @  'abc  123   '
      INSERT('123','abc',5,6,'+')  @  'abc++123+++'
      INSERT('123,'abc')           @  '123abc'
      INSERT('123','abc',,5,'-')   @  '123--abc'
      INSERT('123','abc',5,,'-')   @  'abc--123'

   See Also

      COPIES( )   Returns a number of copies of a string, directly
                  concatenated

      SUBSTR( )   Returns a substring of a string, by character






                                Page [124]

   --------------------------------------------------------------------
                                 LASTPOS
   --------------------------------------------------------------------


   Purpose

      Finds the position of a substring in another string, by scanning
      backwards.

   Syntax

      ÄLASTPOS(needle,haystackÄÂÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                                 ÀÄ,startÄÙ

   Parameters

      needle   The string to find

      haystack The string to search

      start    The point at which to start the backwards scan.  Start
               must be a positive whole number.  The default is to
               start at the last character of haystack and scan back-
               wards.

   Remarks

      Returns the position of the last occurrence of needle, in
      haystack.  If it does not find needle, LASTPOS returns 0.

   Examples

      LASTPOS(' ','abc def ghi')    @  8
      LASTPOS(' ','abcdefghi')      @  0
      LASTPOS(' ','abc def ghi',7)  @  4

   See Also

      POS( )      Returns the position of a substring in another string

      WORDPOS( )  Searches a string for a phrase, and returns the
                  number of the first word in the phrase














                                Page [125]

   --------------------------------------------------------------------
                                   LEFT
   --------------------------------------------------------------------


   Purpose

      Returns the leftmost characters of a string.

   Syntax

      ÄLEFT(string,lengthÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                            ÀÄ,padÄÙ

   Parameters

      string The string to be truncated or padded.

      length The length of the returned string. Length must be a
             non-negative whole number.

      pad    The character to use to pad the string if it is shorter
             than the length.  The default character is a blank.

   Remarks

      If string is longer than length, LEFT truncates the extra charac-
      ters.  If string is shorter than length, LEFT pads on the right.

      This function is exactly the same as:

      ÄSUBSTR(string,1,lengthÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄ
                                ÀÄ,padÄÙ

   Examples

      LEFT('abc d',8)     @  'abc d   '
      LEFT('abc d',8,'.') @  'abc d...'
      LEFT('abc def',6)   @   'abc de'

   See Also

      CENTER( )   Centers a string within a length

      RIGHT( )    Returns characters from the right side of a string

      SPACE( )    Formats the words in a string with pad characters
                  between each word









                                Page [126]

   --------------------------------------------------------------------
                                  LENGTH
   --------------------------------------------------------------------


   Purpose

      Returns the length of a string.

   Syntax

      ÄLENGTH(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      string The string to evaluate

   Examples

      LENGTH('abc')         @  3
      LENGTH('abcdefghij')  @  10
      LENGTH('')            @  0

   See Also

      WORDLENGTH( )Returns the length of a word in a string

      WORDS( )    Returns the number of blank-delimited words in a
                  string




























                                Page [127]

   --------------------------------------------------------------------
                                  LINEIN
   --------------------------------------------------------------------


   Purpose

      Returns lines read from a character input stream.

   Syntax

      ÄLINEIN(ÄÂÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ÀÄnameÄÙ ÀÄ,ÄÂÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÂÄÙ
                              ÀÄlineÄÙÀÄ,countÄÙ

   Parameters

      name   The file name, which can be any system file.  The file
             name can include drive and path specifications.  If you
             omit name, LINEIN reads the line from the default input
             stream.

      line   The line number, which sets the read position to the start
             of a specific line.  A value of 1 specifies the first line
             in the stream.  The default is the current read position.
             When LINEIN completes the read, it increases the read
             position by the number of characters read.

             For persistent streams (for example, files) REXX maintains
             a read position for each stream.  You cannot specify a
             read position for a transient stream.

             Under certain circumstances, a call to LINEIN returns a
             partial line.  For example, when the stream has already
             been read with the CHARIN function, and part but not all
             of a line (and its termination) has been read.

      count  The number of lines read.  The default is 1.  If you
             specify a count of 0, REXX sets the read position to the
             start of line, but does not read any characters and
             returns the null string.

   Remarks

      If a complete line is not available in the stream, program execu-
      tion stops until the line becomes available.  If, however, it is
      impossible for a line to be completed, LINEIN returns with what-
      ever characters are available.

      LINEIN may return a partial line if part of a line has been read
      using the CHARIN function, and line termination was not read.






                                Page [128]

   Examples

      1 LINEIN(infile)      @  'CTC'
      2 LINEIN(infile,3)    @  'Line3'
      3 LINEIN(infile,8,0)  @  ''
      4 LINEIN(infile)      @  'Line8'
      5 LINEIN( )           @  'Hi'
      6 LINEIN('QUEUE:')    @  'queued line'

        1:Reads the current line
        2:Reads line 3
        3:Sets the read position at line 8
        4:Reads line 8
        5:Uses the default stream
        6:Uses the default data queue

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream
























                                Page [129]

   --------------------------------------------------------------------
                                 LINEOUT
   --------------------------------------------------------------------


   Purpose

      Writes a string to a character output stream.

   Syntax

      ÄLINEOUT(ÄÂÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄ
                  ÀÄnameÄÙ ÀÄ,ÄÂÄÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÂÄÙ
                               ÀÄstringÄÙÀÄ,lineÄÙ

   Parameters

      name   The name of the output device, which is usually a file
             name.  The file name can include drive and path specifica-
             tions.  If you omit name, REXX writes the line to the
             default output stream.

      string The string to write.  You can specify the null string, in
             which case only the action associated with completing the
             line is taken.  You can omit this argument for persistent
             streams, for example, files and objects.  In this case,
             CHAROUT sets the write position to the value of line, does
             not write any lines to the stream, and returns 0.

      line   The explicit write position for the write to start.  The
             line number must be positive and within the bounds of the
             stream, although it can specify the character position
             immediately after the end of the stream.  A value of 1
             specifies to start the write at the first line in the
             stream.  The default is to start at the current write
             position.

   Remarks

      For persistent streams, LINEOUT maintains a write position for
      each stream.  LINEOUT conceptually terminates a line at the end
      of each call.  When LINEOUT completes the write, it increases the
      write position by the number of characters written.  The initial
      write position is the end of the stream, so that calls to LINEOUT
      normally append lines to the end of the stream.  (Unless the
      stream was opened using the STREAM() function).

      If you do not specify a line position or a string, LINEOUT sets
      the write position to the end of the stream, closes the file, and
      returns 0.

      The program stops executing until the output operation is effec-
      tively complete.  If, however, LINEOUT cannot write all the char-
      acters, it returns with the number of lines that could not be
      written (the residual count).


                                Page [130]

   Examples

      1 LINEOUT(outfile,'At')    @  0
      2 LINEOUT(outfile,'At',4)  @  0
      3 LINEOUT(outfile,,5)      @  0
      4 LINEOUT(outfile)         @  0
      5 LINEOUT(,'At')           @  0
      6 LINEOUT(,'Think')        @  1
      7 LINEOUT('PRN')           @  0
      8 LINEOUT('LPT1')          @  0
      9 LINEOUT('QUEUE:','At')   @  0

        1:Indicates a normal return
        2:Indicates a normal return
        3:Sets the write position to line 5
        4:Sets the write position to the end of file
        5:Indicates a normal return
        6:The line was not written
        7:Sets the default printer as the output device
        8:Sets the printer LPT1 as the output device
        9:Writes 'At' to the default data queue

   Examples

      This routine is often best called as a subroutine.  The residual
      count is then available in the special variable RESULT.

      Call LINEOUT outfile, 'Think'
      Call LINEOUT outfile, 'At',5
      Call LINEOUT outfile
      Call LINEOUT 'LPT1', 'This line sent to LPT1'

      Note:  If the lines are to be written to the default output
      stream and no error is possible, you would usually use the SAY
      instruction.

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream


                                Page [131]

   --------------------------------------------------------------------
                                  LINES
   --------------------------------------------------------------------


   Purpose

      Returns the total number of complete lines remaining in a
      character input stream.  For persistent streams, the count starts
      at the current read position.

   Syntax

      ÄLINES(ÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                ÀÄnameÄÙ

   Parameter

      name   The file name, which can be any system file name,
             including specific device names.  If you omit name, LINES
             returns the number of lines available in the default input
             stream.

   Remarks

      1. If a stream has been read with the CHARIN function, the number
         of complete lines might include a partial line.

      2. If LINES cannot determine the count accurately or efficiently,
         it might return 1 or more for any nonzero result.

      3. Use the CHARS function to return the number of characters
         (rather than lines) in the stream.

   Examples

      LINES(myfile)       @  42
      LINES(nonfile)      @  0
      LINES( )            @  27

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream

                                Page [132]

   --------------------------------------------------------------------
                                   MAX
   --------------------------------------------------------------------


   Purpose

      Returns the largest number from the given list of numbers.

   Syntax

      ÄMAX(numberÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                    ³ ÚÄÄÄÄÄÄÄÄÄ¿ ³
                    ÀÄÄ,numberÄÁÄÙ

   Parameters

      number The first number in the list

      number The other number(s) in the list

   Remarks

      MAX formats the result according to the current NUMERIC instruc-
      tion settings.

   Examples

      MAX(22,49,7,3)      @  49
      MAX(12.3,22.5,1.3)  @  22.5
      MAX(-2,-5,-1.3)     @  -1.3

   See Also

      MIN( )      Returns the smallest number from the given list of
                  numbers





















                                Page [133]

   --------------------------------------------------------------------
                                   MIN
   --------------------------------------------------------------------


   Purpose

      Returns the smallest number from the given list of numbers.

   Syntax

      ÄMIN(numberÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                    ³ ÚÄÄÄÄÄÄÄÄÄ¿ ³
                    ÀÄÄ,numberÄÁÄÙ

   Parameters

      number The first number in the list

      number The other number(s) in the list

   Remarks

      MIN formats the result according to the current NUMERIC instruc-
      tion settings.

   Examples

      MIN(22,49,7,3)      @  3
      MIN(12.3,22.5,1.3)  @  1.3
      MIN(-2,-5,-1.3)     @  -5

   See Also

      MAX( )      Returns the largest number from the given list of
                  numbers





















                                Page [134]

   --------------------------------------------------------------------
                                 OVERLAY
   --------------------------------------------------------------------


   Purpose

      Overlays one string onto another string.

   Syntax

      ÄOVERLAY(string,targetÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂ)ÄÄÄ
                               À,ÂÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÙ
                                 ÀÄnÄÙÀ,ÂÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÂÙ
                                        ÀÄlengthÄÙ ÀÄ,padÄÙ

   Parameters

      string The overlay string

      target The string that will be overlaid

      n      The position in the target string where overlaying is to
             start.  N must be greater than 0.  If n is greater than
             the length of the target string, OVERLAY adds padding
             before the overlay string.

      length The length of the overlay string.  String is padded on the
             right or truncated on the right according to length.
             Length must be a non-negative whole number.  The default
             is the length of the overlay string.

      pad    The character to use for padding.  The default character
             is a blank.

   Remarks

      The function overlays target, starting at the nth character, with
      string.  Before target is overlaid, string will be padded or
      truncated to the size given by length.

   Examples

      OVERLAY(' ','abcdef',4)       @  'abc ef'
      OVERLAY('.','abcdef',4,2)     @  'abc. f'
      OVERLAY('zz','abcd')          @  'zzcd'
      OVERLAY('zz','abcd',4)        @  'abczz'
      OVERLAY('zz','abcd',6,7,'-')  @  'abcd-zz-----'









                                Page [135]

   See Also

      BITAND( )   Returns a string composed of two input strings
                  logically ANDed together

      BITOR( )    Returns a string composed of two input strings
                  logically ORed together

      BITXOR( )   Returns a string composed of two input strings
                  logically exclusive ORed together

      INSERT( )   Inserts a string into another string













































                                Page [136]

   --------------------------------------------------------------------
                                   POS
   --------------------------------------------------------------------


   Purpose

      Returns the position of a substring in another string.

   Syntax

      ÄPOS(needle,haystackÄÂÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                             ÀÄ,startÄÙ

   Parameters

      needle   The substring to find

      haystack The string to search

      start    The point at which to start the search.  The default is
               the first character of haystack (that is, start has the
               value 1). Start must be a positive whole number.

   Remarks

      Returns the position of the first occurence of needle in
      haystack.  If POS does not find the string needle, it returns 0.

   Examples

      POS('is','now is the')    @  5
      POS('at','now is the')    @  0
      POS(' ','abc def ghi')    @  4
      POS(' ','abc def ghi',5)  @  8

   See Also

      LASTPOS( )  Finds the position of a substring in another string,
                  by scanning backwards

      WORDPOS( )  Searches a string for a phrase, and returns the
                  number of the first word in the phrase














                                Page [137]

   --------------------------------------------------------------------
                                  QUEUED
   --------------------------------------------------------------------


   Purpose

      Returns the number of lines remaining in the external data queue
      when the function is invoked.  See "Input and Output" on page
      191.

   Syntax

      ÄQUEUED()ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Example

      QUEUED( )           @  5

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream































                                Page [138]

   --------------------------------------------------------------------
                                  RANDOM
   --------------------------------------------------------------------


   Purpose

      Returns a non-negative whole number chosen at random from an
      inclusive range of numbers.  This can be useful for programming
      games and for statistical models.

   Syntax

      ÄRANDOM(ÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ÃÄmaxÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                 ÃÄmin,ÄÂÄÄÂÄÄÄÄÄÂÂÄÄÄÄÄÄÄÂÄÙ
                 ÀÄ,ÄÄÄÄÙ  ÀÄmaxÄÙÀÄ,seedÄÙ

   Parameters

      min    The minimum number in the range.  The default is 0.

      max    The maximum number in the range.  The default is 999.

      seed   The random number that starts a repeatable sequence of
             results.  Seed must be a whole number.

   Remarks

      The magnitude of the range (that is, max minus min) cannot exceed
      100000.

   Examples

      /* Possible results might be: */
      RANDOM( )           @  305
      RANDOM(5,8)         @  7
      RANDOM(,,1989)      @  663 /* always */
      RANDOM(2)           @  0

   Remarks

      1. To obtain a predictable sequence of quasi-random numbers, call
         RANDOM a number of times, but only specify a seed on the first
         call.  For example, to simulate ten throws of a six-sided
         dice:

         /* Start invoking any number for the seed */
            say random(1,6,777)
             do 9
            say random(1,6)
             end

         The numbers are generated mathematically, using the initial
         seed, They appear to be random as far as possible.  Running


                                Page [139]

         the program again will produce the same sequence.  However,
         using a different initial seed almost always produces a
         different sequence.  If you do not supply a seed the first
         time RANDOM is called, REXX uses an arbitrary (and probably
         time-varying) initial seed.




















































                                Page [140]

   --------------------------------------------------------------------
                                 REVERSE
   --------------------------------------------------------------------


   Purpose

      Reverses the order of characters in a string.

   Syntax

      ÄREVERSE(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      string The string to reverse

   Examples

      REVERSE('Bel.')            @  '.leB'
      REVERSE('TIN ')            @  'NIT'
      REVERSE('AlphabetStreet')  @  'teertStebahplA'



































                                Page [141]

   --------------------------------------------------------------------
                                  RIGHT
   --------------------------------------------------------------------


   Purpose

      Returns the rightmost characters of a string.

   Syntax

      ÄRIGHT(string,lengthÄÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                             ÀÄ,padÄÙ

   Parameters

      string The string to be truncated or padded.

      length The length of the result string. length must be a
             non-negative whole number.

      pad    The character to use to pad the string if it is shorter
             than the length.  The default character is a blank.

   Remarks

      If string is longer than length, RIGHT truncates the extra char-
      acters on the left.  If string is shorter than length, RIGHT pads
      on the left.

   Examples

      1 RIGHT('abcd',6)     @  '  abcd'
      2 RIGHT('abcdef',4)   @  'cdef'
      3 RIGHT('123',6,'0')  @  '000123'

        1:Pads the result on the left
        2:Truncates the result on the left
        3:Pads the result with '0'

   See Also

      CENTER( )   Centers a string within a length

      LEFT( )     Returns characters from the left side of a string

      SPACE( )    Formats the words in a string with pad characters
                  between each word









                                Page [142]

   --------------------------------------------------------------------
                                   SIGN
   --------------------------------------------------------------------


   Purpose

      Tests a number for greater than, less than, or equal to zero
      after rounding.

   Syntax

      ÄSIGN(number)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      number The number to evaluate.

   Remarks

      The number is rounded according to the current setting of the
      NUMERIC DIGITS instruction.  If the number is then less than 0,
      SIGN returns '-1'.  If it is 0, SIGN returns '0'.  If it is
      greater than 0, SIGN returns '1'.

   Examples

      SIGN('123')         @  1
      SIGN('123.45')      @  1
      SIGN('-123')        @  -1
      SIGN(0.0)           @  0

   See Also

      ABS( )      Returns the absolute value of a number






















                                Page [143]

   --------------------------------------------------------------------
                                SOURCELINE
   --------------------------------------------------------------------


   Purpose

      Returns the number of lines in the program, or a line itself.

   Syntax

      ÄSOURCELINE(ÄÂÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                     ÀÄnÄÙ

   Parameter

      n      The number of the line to return, which must be a positive
             whole number.  N cannot exceed the number of the final
             line in the program.

   Examples

      SOURCELINE( )       @  50
      SOURCELINE(1)       @  '/* A 50-line program */'

   See Also

      ERRORTEXT( )Returns the REXX error message associated with error
                  n.




























                                Page [144]

   --------------------------------------------------------------------
                                  SPACE
   --------------------------------------------------------------------


   Purpose

      Formats the words in a string with pad characters between each
      word.

   Syntax

      ÄSPACE(stringÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                      ÀÄ,ÄÂÄÄÄÂÂÄÄÄÄÄÄÂÙ
                          ÀÄnÄÙÀÄ,padÄÙ

   Parameters

      string The string to format

      n      The number of pad characters to use between each word.
             The default is 1.  N must be a non-negative whole number.
             If it is 0, SPACE removes all blanks.  SPACE always
             removes all leading and trailing blanks.

      pad    The pad character to use between each word.  The default
             character is a blank.

   Examples

      SPACE('abc  def  ')         @  'abc def'
      SPACE('  abc def',3)        @  'abc   def'
      SPACE('abc  def  ',3)       @  'abc   def'
      SPACE('abc  def  ',0)       @  'abcdef'
      SPACE('  abc def  ',2,'-')  @  'abc--def'

   See Also

      CENTER( )   Centers a string within a length

      LEFT( )     Returns characters from the left side of a string

      RIGHT( )    Returns characters from the right side of a string

      STRIP( )    Removes the leading, trailing, or both leading and
                  trailing characters from a string











                                Page [145]

   --------------------------------------------------------------------
                                  STREAM
   --------------------------------------------------------------------


   Purpose

      Returns a string that describes the state of, or results of an
      operation upon, a character stream.  See "Input and Output" on
      page 191.  You can use this function to retrieve information
      about the state of a particular input or output stream, or to
      perform an operation on the stream.

   Syntax

      ÄSTREAM(nameÄ,ÄÂÄSÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                       ³                   ³
                       ÃÄDÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                       ³                   ³
                       ÀÄCÄÂÄOPENÄÄÄÄÄÄÄÄÄÂÙ
                           ³              ³
                           ÃÄCLOSEÄÄÄÄÄÄÄÄ´
                           ³              ³
                           ÃÄSEEKÄoffsetÄÄ´
                           ³              ³
                           ÀÄQUERYÄtypeÄÄÄÙ

   Parameters

      name       The stream to access.  If you do not specify a stream
                 name, REXX carries out the operation on the default
                 input stream.

      operation  The operation to perform.  The operations are:

                 S  (State)  Returns a string that describes the
                    current state of the stream; for example, the
                    stream is READY or NOTREADY.  This is the default.

                 D  (Description)  Returns a more detailed description
                    of the current state of the stream.  The returned
                    string is followed by a colon, and if available, an
                    additional descriptive string.

                 C  (Command)  Specifies a "command" or operation to
                    perform on the selected input or output stream.
                    The returned string depends on the command, and
                    might be the null string.  See "Stream commands" on
                    page 147 for a list of valid commands.

   Remarks

      When you specify the State or Description options, STREAM returns
      one of the following strings:



                                Page [146]

      ERROR    An operation on a stream resulted in an error.  To find
               out more about the error, use the Description operation
               described above.

      NOTREADY The stream is not ready for normal input or output oper-
               ations.

      READY    The stream is ready for normal input or output opera-
               tions.

      UNKNOWN  The current state of the stream is unknown.  REXX cannot
               determine the state of the stream until it performs an
               operation on it.


   Stream commands

      Stream commands let you:

      *  Open and close a stream

      *  Get information about a stream

      *  Set or get the file pointer position in a stream

      To issue a stream command, use the Command option, and enclose
      the stream command in quotes.  For example:

      stream(name,c,'open write')

      The stream commands are:

      OPEN       Opens the stream.  The default is to open the stream
                 for both reading and writing data in text mode, for
                 example, STREAM( filename, 'C', 'OPEN TEXT' ).  To
                 open the stream for reading only, specify READ.  To
                 open the stream for writing only, specify WRITE.  To
                 open the stream in binary mode, specify BINARY.

                 If the stream is opened successfully, STREAM returns
                 READY.  If the stream open failed, STREAM returns an
                 appropriate error message.

      CLOSE      Closes the stream.  If the stream is closed success-
                 fully, STREAM returns READY.  If the stream close
                 failed, STREAM returns an appropriate error message.
                 If you try to close an unopened stream, STREAM returns
                 a null string.

      SEEK offsetSets an explicit read or write position within a
                 persistent stream.  See "Input and Output" on page
                 191.  Before you use this command, you must issue the
                 OPEN stream command.  Then, issue the SEEK command
                 with the number of characters from the beginning of a
                 persistent stream.  You can also precede the offset
                 number with one of the following characters:

                                Page [147]

                 =  Explicitly specifies the offset from the beginning
                    of the stream.

                 <  Specifies the offset from the end of the stream.

                 +  Specifies the offset forward from the current read
                    or write position.

                 -  Specifies the offset backward from the current read
                    or write position.

      QUERY type Returns specific information about a streem depending
                 the type:

                 EXIST    Returns the full path specification of the
                          stream, if it exists.  Returns a null string
                          if it does not exist.

                 SIZE     Returns the size of a persistent stream (in
                          bytes).

                 DATETIME Returns the date and time stamps of a stream.

   Remarks

      The STREAM seek function returns the file pointer position after
      the seek operation.

   Examples

      1 stream(name,c,'open')
      2 stream(name,c,'open text')
      3 stream(name,c,'open read')
      4 stream(name,c,'open read text')
      5 stream(name,c,'open write')
      6 stream(name,c,'open write text')
      7 stream(name,c,'open binary')
      8 stream(name,c,'open read binary')
      9 stream(name,c,'open write binary')
      10stream(name,'c','seek +0')
      11stream(name,'c','seek +2')

        1:opens the stream for reading and writing in text mode
        2:opens the stream for reading and writing in text mode
        3:opens the stream for reading in text mode
        4:opens the stream for reading in text mode
        5:opens the stream for writing in text mode
        6:opens the stream for writing in text mode
        7:opens the stream for reading and writing in binary mode
        8:opens the stream for reading in binary mode
        9:opens the stream for writing in binary mode
        10:returns 20
        11:returns 22




                                Page [148]

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes  a string to a character output stream

      LINES( )    Returns the total number of complete lines remaining
                  in a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      QUEUED( )   Returns the number of lines remaining in the external
                  data queue






































                                Page [149]

   --------------------------------------------------------------------
                                  STRIP
   --------------------------------------------------------------------


   Purpose

      Removes the leading, trailing, or both leading and trailing char-
      acters from a string.

   Syntax

      ÄSTRIP(stringÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                      ÀÄ,ÄÂÄÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÂÙ
                          ÀÄoptionÄÙÀÄ,charÄÙ

   Parameters

      string The string from which to remove the characters

      option The type of characters to remove.  The options can be in
             upper or lowercase.  The options are:

             L  Removes leading characters

             T  Removes trailing characters

             B  Removes both leading and trailing characters (the
                default).

      char   The character to remove.  The default is a blank.  Char
             must be exactly one character long.

   Examples

      STRIP('  ab cd  ')      @  'ab cd'
      STRIP('  ab cd  ','B')  @  'ab cd'
      STRIP('  ab cd  ','L')  @  'ab cd  '
      STRIP('  ab cd  ','T')  @  '  ab cd'
      STRIP('12.3400',,0)     @  '12.34'
      STRIP('0012.3400',,0)   @  '12.34'

   See Also

      CENTER( )   Centers a string within a length

      LEFT( )     Returns characters from the left side of a string

      RIGHT( )    Returns characters from the right side of a string

      SPACE( )    Formats the words in a string with pad characters
                  between each word





                                Page [150]

   --------------------------------------------------------------------
                                  SUBSTR
   --------------------------------------------------------------------


   Purpose

      Returns a substring of a string, by character.

   Syntax

      ÄSUBSTR(string,nÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                         ÀÄ,ÄÂÄÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÂÙ
                             ÀÄlengthÄÙÀÄ,padÄÙ

   Parameters

      string The string from which to derive the substring.

      n      The character position at which to start the substring.  N
             must be positive.  If n is greater than the length of the
             string, SUBSTR returns pad characters only.

      length The length of the substring.  The default is the rest of
             the string.

      pad    The pad character to use to pad the substring, if neces-
             sary.  The default character is a blank.

      Note:   In some situations it might be more convenient to use the
      positional (numeric) patterns of parsing templates to select
      substrings, especially if you want to extract more than one
      substring from a string.

   Examples

      SUBSTR('abcde',2)        @  'bcde'
      SUBSTR('abcde',2,5)      @  'bcde '
      SUBSTR('abcde',1,3)      @  'abc'
      SUBSTR('abcde',2,6,'.')  @  'bcde..'

   See Also

      LEFT( )     Returns characters from the left side of a string

      RIGHT( )    Returns characters from the right side of a string

      STRIP( )    Removes the leading, trailing, or both leading and
                  trailing characters from a string.

      SUBWORD( )  Returns a substring of a string, by word






                                Page [151]

   --------------------------------------------------------------------
                                 SUBWORD
   --------------------------------------------------------------------


   Purpose

      Returns a substring of a string, by word.

   Syntax

      ÄSUBWORD(string,nÄÂÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                          ÀÄ,lengthÄÙ

   Parameters

      string The string from which to derive the substring.

      n      The number of the word that starts the substring.  N must
             be positive.

      length The length of the substring, in blank-delimited words.
             The default is the remaining words in the string.  Length
             must be a non-negative whole number.

   Remarks

      SUBWORD always removes all the leading and trailing blanks in the
      returned string, but includes all blanks between the selected
      words.

   Examples

      SUBWORD('Now is the  time',2,2)  @  'is the'
      SUBWORD('Now is the  time',3)    @  'the  time'
      SUBWORD('Now is the  time',4)    @  'time'
      SUBWORD('Now is the  time',5)    @  ''

   See Also

      WORDPOS( )  Searches a string for a phrase, and returns the
                  number of the first word in the phrase

      WORDS( )    Returns the number of blank-delimited words in a
                  string












                                Page [152]

   --------------------------------------------------------------------
                                  SYMBOL
   --------------------------------------------------------------------


   Purpose

      Indicates whether a symbol has already been used as a name of a
      variable.

   Syntax

      ÄSYMBOL(name)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      name   The symbol to evaluate

   Returns

      BAD    If name is not a valid REXX symbol

      VAR    If name is the name of a variable (that is, a symbol that
             has been assigned a value)

      LIT    If name is either a constant symbol or a symbol that has
             not yet been assigned a value (that is, a literal).

   Remarks

      SYMBOL translates lowercase characters in the name to upper case
      and performs substitution in a compound name.

      Note:   To prevent substitution in a name by its value before it
      is passed to the function, specify it as a literal string (or
      derive the name from an expression).

   Examples

      These examples follow:   Drop A.3;  J=3

      1 SYMBOL('J')         @  'VAR'
      2 SYMBOL(J)           @  'LIT'
      3 SYMBOL('a.j')       @  'LIT'
      4 SYMBOL(2)           @  'LIT'
      5 SYMBOL('*')         @  'BAD'

        1:Found "J" to be the name of a variable
        2:Tested "3"
        3:Tested "A.3"
        4:Found 2 to be a constant symbol
        5:Tested *, which is not a valid symbol

   See Also

      VALUE( )    Returns the value of a symbol

                                Page [153]

   --------------------------------------------------------------------
                                   TIME
   --------------------------------------------------------------------


   Purpose

      Returns the local time.  The default format is the 24-hour clock,
      'hh:mm:ss' (hours, minutes, and seconds).  For example,
      '04:41:37'.

   Syntax

      ÄTIME(option)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      option Returns a different format or accesses the elapsed time
             clock.  The options are:

             C  (Civil) Returns 'hh:mmxx', the time in civil format, in
                which the hours can take the values 1 through 12, and
                the minutes the values 00 through 59.  The minutes are
                followed immediately by the letters "am" or "pm".  The
                hour does not have a leading zero.  The minute field
                shows the current minute (rather than the nearest
                minute) for consistency with other TIME results.

             E  (Elapsed) Returns 'sssssssss.uuuuuu', the number of
                seconds (and microseconds) since the elapsed time clock
                was started or reset (see below).  The number does not
                have leading zeros or blanks, and is not affected by
                the setting of NUMERIC DIGITS.

             H  (Hours) Returns the number of hours since midnight in
                the format 'hh' (no leading zeros or blanks).

             L  (Long) Returns the time in the format 'hh:mm:ss.uuuuuu'
                (uuuuuu is the fraction of seconds, in microseconds).

             M  (Minutes) Returns the number of minutes since midnight
                in the format 'mmmm' (no leading zeros or blanks).

             N  (Normal) Explicitly returns the time in the default
                format 'hh:mm:ss', as described above.

             R  (Reset) Returns  'sssssssss.uuuuuu', the number of
                seconds.microseconds since the elapsed time clock was
                started or reset (see below), and also simultaneously
                resets the elapsed time clock to zero.  The number does
                not have leading zeros or blanks, and is not affected
                by the setting of NUMERIC DIGITS.

             S  (Seconds) Returns number of seconds since midnight in
                the format 'sssss' (no leading zeros or blanks).


                                Page [154]

   Examples

      1 TIME('C')  @  '4:54pm'
      2 TIME('H')  @  16
      3 TIME('L')  @  '16:54:22.123456'
      4 TIME('M')  @  1014
      5 TIME('n')  @  '16:54:22'
      6 TIME('s')  @  60862

        4:54 + 60*16
        6:22+60*(54+60*16)

   Example

      Measuring elapsed time intervals

      You can use the TIME function to measure real (elapsed) time
      intervals.  On the first call in a program to TIME('E') or
      TIME('R'), the elapsed time clock is started and either call
      returns 0.  From then on, calls to TIME('E') and to TIME('R')
      return the elapsed time since that first call or since the last
      call to TIME('R').

      1 TIME('E')  @  0
      2 TIME('E')  @  1.002345
      3 TIME('R')  @  2.004690
      4 TIME('R')  @  1.002345

        1:The first call pause of one second
        2:One second pause, or thereabouts
        3:One second pause, or thereabouts
        4:Or thereabouts

      The clock is saved across internal routine calls.  This means
      that an internal routine inherits the time clock started by its
      caller, but if it resets the clock it does not affect any timing
      being done by the caller.

      Note:  The first call to TIME in a clause makes a time stamp,
      which REXX then uses for all calls to TIME or DATE within that
      clause.  This guarantees consistency among multiple calls made to
      TIME or DATE in a single expression or clause.  Since the clock
      is synchronized, the interval between two normal TIME results can
      be calculated exactly by the elapsed time clock.

   See Also

      DATE( )     Returns the local date in many different formats









                                Page [155]

   --------------------------------------------------------------------
                                  TRACE
   --------------------------------------------------------------------


   Purpose

      Returns the trace setting currently in effect, and optionally
      alters the setting.

   Syntax

      ÄTRACE(ÄÂÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                ÀÄsettingÄÙ

   Parameter

      setting  Selects the trace setting.  setting must be a valid
               prefix ("?") and/or one of the following:

               A  (All) Traces all clauses before execution.

               C  (Commands) Traces all host commands before execution.
                  If the command results in an error or failure, then
                  the return code from the command is also shown.

               E  (Error) Traces any host command resulting in an error
                  or failure (after execution), together with the
                  return code from the command.

               F  (Failure) Traces any host command resulting in a
                  failure (after execution), together with the return
                  code from the command.  This is the same as the
                  default setting, Normal.

               I  (Intermediates) as "R" except that all terms and
                  intermediate results during expression evaluation
                  (and substituted names) are also traced.

               L  (Labels) Traces only labels passed during execution.
                  This is especially useful while tracing
                  interactively, when the language processor pauses
                  after each label; or if you want to note all internal
                  subroutine calls and signals.

               N  (Normal) Traces nothing except host commands
                  resulting in failure.  These are traced (after execu-
                  tion) together with the return code from the command.
                  This is the default.

               O  (Off) Traces nothing, and turns off interactive trac-
                  ing.





                                Page [156]

               R  (Results) Traces all clauses before execution,
                  together with the final result of any expression
                  evaluated.  Values assigned during PULL, ARG, and
                  PARSE instructions are also displayed.  We recommend
                  this setting for general debugging.

   Remarks

      Unlike the TRACE instruction, the TRACE function alters the trace
      setting even if interactive tracing is active.  Also, unlike the
      TRACE instruction, setting cannot be a number.

   Examples

      TRACE( )            @  '?R'
      TRACE('0')          @  '?R' /* set tracing off */









































                                Page [157]

   --------------------------------------------------------------------
                                TRANSLATE
   --------------------------------------------------------------------


   Purpose

      Translates characters in a string to other characters, or reor-
      ders characters in a string.  For example, you might use this
      function to translate data before sending it from an EBCDIC
      computer to an ASCII printer or to change the punctuation in a
      program.

   Syntax

      ÄTRANSLATE(stringÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄ
                         ÀÄ,ÄÂÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÙ
                             ÀtableoÙÀÄ,ÄÂÄÄÄÄÄÄÂÄÂÄÄÄÄÂÙ
                                         ÀtableiÙ À,padÙ

   Parameters

      string The string to translate or reorder

      tableo The output translate table to use for the translation.
             The default output table is the null string.  Tableo is
             padded or truncated on the right as needed.

      tablei The input translate table to use for the translation.  The
             default is XRANGE('00'x,'FF'x).

      pad    The pad character to use to pad the default output table.
             The default pad character is a blank.

   Remarks

      If you do not specify either table, TRANSLATE simply translates
      the string to upper case.

      The tables can be any length: TRANSLATE uses the first occurrence
      of a character in the input table if there are duplicates.  If
      the length of the output table is less than the length of the
      input table, the output table is padded on the right with the pad
      character.  All characters in string that are found in tablei
      will be replaced by corresponding characters in tableo.  If a
      character in string does not appear in tablei, it appears in the
      result string unchanged.










                                Page [158]

   Examples

      TRANSLATE('abcdef')                  @  'ABCDEF'
      TRANSLATE('abbc','-','b')            @  'a--c'
      TRANSLATE('abcdef','12','db')        @  'a2c1ef'
      TRANSLATE('abcdef','12','abcd','.')  @  '12..ef'
      TRANSLATE('file.ext',' ','.')        @  'file ext'
      TRANSLATE('4123','abcd','1234')      @  'dabc'

      Note: The last example shows how the TRANSLATE function can be
      used to reorder the characters in a string.  In the example, any
      4-character string could be specified as the second argument, and
      its last character would be moved to the beginning of the string.

   See Also

      REVERSE( )  Swaps a string end for end

      VERIFY( )   Verifies whether a character string is, or is not, a
                  member of a given character set





































                                Page [159]

   --------------------------------------------------------------------
                                  TRUNC
   --------------------------------------------------------------------


   Purpose

      Rounds a number down.

   Syntax

      ÄTRUNC(numberÄÂÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                      ÀÄ,nÄÙ

   Parameters

      number The number to round down

      n      The number of digits after the decimal point.  n must be a
             non-negative whole number.  The default is 0, which
             returns an integer with no decimal point.  TRUNC truncates
             the number to n decimal places, or adds trailing zeros if
             needed to make up the specified length.  The result is
             never in exponential form.

   Examples

      TRUNC(123.45)       @  123
      TRUNC(123.4567,3)   @  123.456
      TRUNC(123.4,3)      @  123.400
      TRUNC(123,2)        @  123.00

      Note: The number will be rounded according to the current setting
      of NUMERIC DIGITS, if necessary, before being processed by the
      function.

   See Also

      FORMAT( )   Rounds and formats a number


















                                Page [160]

   --------------------------------------------------------------------
                                  VALUE
   --------------------------------------------------------------------


   Purpose

      Returns the value of a symbol, and optionally assigns it a new
      value.

   Syntax

      ÄVALUE(nameÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄ
                    ÀÄ,ÄÂÄÄÄÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÙ
                        ÀÄnewvalueÄÙÀÄ,environmentÄÙ

   Parameters

      name        The symbol name to evaluate, which must be a valid
                  REXX symbol.  VALUE translates lowercase characters
                  in the name to upper case and performs substitution
                  in a compound name.

      newvalue    The new value to assign to the symbol.   The new
                  value does not affect the result returned.

      environment The variables environment to manipulate.  By default,
                  VALUE refers to the current REXX variables environ-
                  ment.    You can use this option to select an
                  external collection of variables.  For example, to
                  manipulate system environment variables, environment
                  must be CMD, or an expression so evaluated.  If you
                  select a variables environment other than the REXX
                  variables environment, name does not have to be a
                  valid REXX symbol.

   Examples

      These examples follow:  Drop A1; A11=7; K=1; rick='K'

      1 VALUE('rick')                 @  'K'
      2 VALUE(rick)                   @  '1'
      3 VALUE('a'k)                   @  'A1'
      4 VALUE('a'k||k)                @  '7'
      5 VALUE('a1','Steak')           @  'A1'
      6 VALUE('a1')                   @  'Steak'
      7 VALUE('path',,'CMD')          @  'C:\OS2'
      8 VALUE('EVAR','FooBar','CMD')  @  ''
      9 VALUE('EVAR','','CMD')        @  'FooBar'

        1:'rick' is looked up; 'K' returned
        2:RICK has the value 'K'; 'K' is looked up; '1' returned
        3:A1 has the value 'A1'; 'A1' is looked up; 'A1' returned
        4:A11 is looked up; '7' returned
        5:Assign REXX variable A1 the value 'Steak'
        6:Get value of A1; it is now 'Steak'

                                Page [161]

        7:Get the system PATH environment variable
        8:Set a system environment variable named EVAR with the value
          'FooBar'
        9:Get the value of system environment variable 'EVAR'

   Remarks

      1. Use the SYMBOL function to test the validity of a symbol.

      2. Use the VALUE function when a variable contains the name of
         another variable, or when a name is constructed dynamically,
         as in examples 3 and 4.  It is not useful to specify the name
         as a quoted literal string, since the symbol is then constant,
         and so the whole function call could be replaced directly by
         the string between the quotes.  (For example,
         "rick=Value('k');" is always identical to the assignment
         "rick=k;".)

   See Also

      SYMBOL( )   Indicates whether a symbol has already been used as a
                  name of a variable



































                                Page [162]

   --------------------------------------------------------------------
                                  VERIFY
   --------------------------------------------------------------------


   Purpose

      Verifies whether a character is, or is not, a member of a given
      character set.

   Syntax

      ÄVERIFY(string,referenceÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄ
                                 ÀÄ,ÄÂÄÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÄÄÂÙ
                                     ÀÄoptionÄÙÀÄ,startÄÙ

   Parameters

      string     The string to verify

      reference  The character set to use to check the string

      option     The verification method.  The options are:

                 N  No match, which returns the position of the first
                    character in string that is not in reference.  If
                    all characters in string are also found in
                    reference, zero is returned.  This is the default
                    option.

                 M  Match, which returns the position of the first
                    character in string that is also in reference, or 0
                    if it finds none of the characters.

      start      The character position to start the search.  The
                 default is 1, which starts the search at the first
                 character of string. Start must be a non-negative
                 whole number.

   Remarks

      If string is null, VERIFY returns 0, regardless of the value of
      option.  Similarly if start is greater than LENGTH(string),
      VERIFY returns 0.

   Examples

      VERIFY('123','1234567890')            @  0
      VERIFY('12Z','1234567890')            @  3
      VERIFY('123','1234567890','M')        @  1
      VERIFY('AB7D','1234567890','M')       @  3
      VERIFY('A12Y4','1234567890',,3)       @  4
      VERIFY('ABC1EF4','1234567890','M',5)  @  7




                                Page [163]

   See Also

      TRANSLATE( )Translates characters in a string

      DATATYPE( ) Checks that characters in a string are valid
                  according to some data type.



















































                                Page [164]

   --------------------------------------------------------------------
                                   WORD
   --------------------------------------------------------------------


   Purpose

      Returns a word from a string.

   Syntax

      ÄWORD(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameters

      string The string in which the word appears

      n      The number of the word in the string

   Remarks

      If there are less than n words in string, WORD returns the null
      string.  This function is exactly equivalent to

      SUBWORD(string,n,1).

   Examples

      WORD('Now is the time',3)  @  'the'
      WORD('Now is the time',5)  @  ''

   See Also

      SUBWORD( )  Returns a substring of a string, by word

      WORDS( )    Returns the number of blank-delimited words in a
                  string




















                                Page [165]

   --------------------------------------------------------------------
                                WORDINDEX
   --------------------------------------------------------------------


   Purpose

      Returns the character position of a word in a string.

   Syntax

      ÄWORDINDEX(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameters

      string The string in which the word appears

      n      The character position of the word in a string.  N must be
             positive.  If there are not n words in the string,
             WORDINDEX returns 0.

   Examples

      WORDINDEX('Now is the time',2)  @  5
      WORDINDEX('Now is the time',3)  @  8
      WORDINDEX('Now is the time',6)  @  0

   See Also

      WORDLENGTH( )Returns the length of a word in a string

      WORDS( )    Returns the number of blank-delimited words in a
                  string

      WORDPOS( )  Searches a string for a phrase, and returns the
                  number of the first word in the phrase





















                                Page [166]

   --------------------------------------------------------------------
                                WORDLENGTH
   --------------------------------------------------------------------


   Purpose

      Returns the length of a word in a string.

   Syntax

      ÄWORDLENGTH(string,n)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameters

      string The character string in which the word appears

      n      The number of the word in the string.  N must be positive.

   Remarks

      Returns the length of the nth blank-delimited word in string.  If
      there are no n words in the string, WORDLENGTH returns 0.

   Examples

      WORDLENGTH('Now is the time',1)  @  3
      WORDLENGTH('Now is the time',4)  @  4
      WORDLENGTH('Now is the time',6)  @  0

   See Also

      LENGTH( )   Returns the length of a string

      WORD( )     Returns a word from a string.

      WORDINDEX( )Returns the character position of a word in a string

      WORDS( )    Returns the number of blank-delimited words in a
                  string

















                                Page [167]

   --------------------------------------------------------------------
                                 WORDPOS
   --------------------------------------------------------------------


   Purpose

      Searches a string for the first occurrence of a phrase, and
      returns the number of the first word in the phrase.

   Syntax

      ÄWORDPOS(phrase,stringÄÂÄÄÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                               ÀÄ,startÄÙ

   Parameters

      phrase The phrase to find.  If WORDPOS does not find the phrase
             in the string, it returns 0.

      string The string to be searched

      start  The number of the word to start the search.  The default
             is to start the search at the first word in the string.
             Start must be positive.

   Remarks

      WORDPOS treats multiple blanks between words in either phrase or
      string as a single blank for the comparison, but otherwise the
      words must match exactly.

   Examples

      WORDPOS('the','now is the time')         @  3
      WORDPOS('The','now is the time')         @  0
      WORDPOS('tim','now is the time')         @  0
      WORDPOS('is the','now is the time')      @  2
      WORDPOS('is    the','now is the time')   @  2
      WORDPOS('is   time','now is  the time')  @  0
      WORDPOS('be','To be or not to be')       @  2
      WORDPOS('be','To be or not to be',3)     @  6

   See Also

      LASTPOS( )  Finds the position of a substring in another string,
                  by scanning backwards

      POS( )      Returns the position of a substring in another string








                                Page [168]

   --------------------------------------------------------------------
                                  WORDS
   --------------------------------------------------------------------


   Purpose

      Returns the number of blank-delimited words in a string.

   Syntax

      ÄWORDS(string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      string The string to evaluate

   Examples

      WORDS('Now is the time')    @  4
      WORDS('Now   is the time')  @  4
      WORDS(' ')                  @  0

   See Also

      SUBWORD( )  Returns a substring of a string, by word

      WORD( )     Returns a word from a string.





























                                Page [169]

   --------------------------------------------------------------------
                                  XRANGE
   --------------------------------------------------------------------


   Purpose

      Returns a string of all one byte character representations within
      a range of characters.

   Syntax

      ÄXRANGE(ÄÂÄÄÄÄÄÄÄÂÂÄÄÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                 ÀÄstartÄÙÀÄ,endÄÙ

   Parameters

      start  The starting character.  The default is '00'x.

      end    The ending character.  The default is 'FF'x.

   Remarks

      If start is greater than end, the values will wrap from 'FF'x to
      '00'x.  start and end must be single characters.

   Examples

      XRANGE('a','f')     @  'abcdef'
      XRANGE('03'x,'07'x) @  '0304050607'x
      XRANGE(,'04'x)      @  '0001020304'x
      XRANGE('FE'x,'02'x) @  'FEFF000102'x

























                                Page [170]

   --------------------------------------------------------------------
                                   X2B
   --------------------------------------------------------------------


   Purpose

      Converts a value in hexadecimal to a binary string.

   Syntax

      ÄX2B(hex-string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      hex-string The hexadecimal string to convert, which can be the
                 null string, in which case X2B returns a null string.

   Remarks

      If necessary, X2B pads hex-string with a leading 0 to make an
      even number of hexadecimal digits.

      You can optionally add blanks at byte boundaries (not leading or
      trailing) to aid readability; they are ignored.

   Examples

      X2B('CF')           @  '11001111'B
      X2B('170')          @  '000101110000'B
      X2B('41')           @  '01000001'B
      X2B(' ')            @  ' '

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2D( )      Converts an ASCII character to its value in decimal

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2C( )      Converts a value in decimal to an ASCII character

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2C( )      Converts a value in hexadecimal to an ASCII character

      X2D( )      Converts a value in hexadecimal to a decimal value








                                Page [171]

   --------------------------------------------------------------------
                                   X2C
   --------------------------------------------------------------------


   Purpose

      Converts hexadecimal to character (packs).

   Syntax

      ÄX2C(hex-string)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

   Parameter

      hex-string The hexadecimal string to pack, which can be the null
                 string, in which case X2C returns a null string.

   Remarks

      If necessary, X2C pads hex-string with a leading 0 to make an
      even number of hexadecimal digits.

      You can optionally add blanks at byte boundaries (not leading or
      trailing) to aid readability; they are ignored.

   Examples

      X2C('31 32 73')     @  '12s'
      X2C('313273')       @  '12s'
      X2C('F')            @  '0F'x

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2D( )      Converts an ASCII character to its value in decimal

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2C( )      Converts a value in decimal to an ASCII character

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2B( )      Converts a value in hexadecimal to a binary string

      X2D( )      Converts a value in hexadecimal to a decimal value









                                Page [172]

   --------------------------------------------------------------------
                                   X2D
   --------------------------------------------------------------------


   Purpose

      Converts hexadecimal to decimal.

   Syntax

      ÄX2D(hex-stringÄÂÄÄÄÄÂÄ)ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                        ÀÄ,nÄÙ

   Parameters

      hex-string The string of hexadecimal characters to convert, which
                 can be the null string, in which case X2D returns '0'.

      n          The number of hexadecimal digits to use to pad
                 hex-string.

   Remarks

      If the result cannot be expressed as a whole number, an error
      results - that is, the result must have no more digits than the
      setting of NUMERIC DIGITS.

      If n is not specified, hex-string is taken to be an unsigned
      number.

   Examples

      X2D('1A')           @  26
      X2D('1F0')          @  496
      X2D('0FFF')         @  4095
      X2D('1000')         @  4096
      X2D('0F FF'x)       @  4095

      If n is specified, hex-string is taken to represent a
      two's-complement number expressed as n hexadecimal characters,
      and is converted to a REXX whole number which might, therefore,
      be negative.  If n is 0, 0 is always returned.

      If necessary, hex-string is padded on the left with 0 characters
      (note, not "sign-extended"), or truncated on the left, to length
      n characters; (that is, as though RIGHT(string,n,'0') had been
      executed.)









                                Page [173]

   Examples

      X2D('81',2)         @  -127
      X2D('81',4)         @  129
      X2D('F081',4)       @  -3967
      X2D('F081',3)       @  129
      X2D('F081',2)       @  -127
      X2D('F081',1)       @  1
      X2D('0031',0)       @  0

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2D( )      Converts an ASCII character to its value in decimal

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      D2C( )      Converts a value in decimal to an ASCII character

      D2X( )      Converts a value in decimal to a hexadecimal value

      X2B( )      Converts a hexadecimal value to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character































                                Page [174]




                               Chapter 10.
                                 Parsing




      The instructions ARG, PARSE, and PULL parse (split up) a
      character string and assign it to variables, under the control of
      a template.  The template controls how data is parsed among vari-
      ables.  Strings can be parsed by:

      *  Word patterns

      *  String patterns

      *  Numeric patterns

      A basic template consists of alternating pattern specifications
      and variable names.  REXX uses the pattern specifications and
      variables strictly in sequence from left to right, and uses them
      only once.  Templates can have variable names without patterns in
      between, and patterns without intervening variable names.

      If the first item in a template is a variable, there is an
      implicit pattern on the left that matches the start of the
      string.  Similarly, if the last item in a template is a variable,
      there is an implicit pattern on the right that matches the end of
      the string.  Therefore the simplest template consists of a single
      variable name which in this case is assigned the entire input
      string.

      Setting a variable during parsing is identical to setting a vari-
      able in an assignment.  This means you can set an entire collec-
      tion of compound variables during parsing.  See "Compound
      symbols" on page 23.

      In general, when the parser splits up a character string, it:

      1. Scans the template for patterns, enclosed in quotes.  When it
         finds patterns, it subdivides the data in the character string
         based upon the match of patterns.

      2. Scans the template again for variables.  When it finds vari-
         ables, it assigns the subdivisions to the variables.


   Parsing With Words

      A simple parsing template consists of a list of variable names.
      The parser splits up the string into words (characters delimited
      by blanks), and assigns each word from the string to a variable
      in sequence from left to right.  The final variable is treated


                                Page [175]

      specially;  the parser assigns to it whatever is left of the
      original string.  The final variable can therefore contain
      several words.  For example:

      'Here today gone tomorrow.' with v1 v2 v3

      sets:

      *  V1 to the value "Here"

      *  V2 to the value "today"

      *  V3 to the value "gone tomorrow."

      The parser removes leading blanks from each word in the string
      before it assigns the word to a variable, as it is the blank that
      delimits the end of the word.  Thus variables set by word
      patterns (V1 and V2 in the example) will never contain leading or
      trailing blanks, though V3 could have both leading and trailing
      blanks.

      If you use PARSE UPPER (or the ARG or PULL instruction), the
      parser translates the whole string into upper case before parsing
      begins.


   Running out of string data

      The parser always assigns every variable in a template a new
      value.  If there are more variables in the template than words in
      the string, the parser sets the unused variables to a null
      string.


   Parsing With Patterns

      Patterns fall into two categories:

      1. Patterns that search for a matching string

         1) Literal patterns

         2) Variable patterns

      2. Numeric patterns that specify a position in the data

         1) Positional patterns

         2) Relative patterns


   Parsing with literal patterns

      You can use a literal string pattern in a template to split up
      the string.  The string pattern is enclosed in quotes.  The


                                Page [176]

      parser places input into a variable named in the template until
      the input matches the literal pattern.  The following example
      uses the comma as a pattern.  The parser scans the string for the
      comma, and splits at that point.

      parse value 'Easy come, easy go' with w1 ',' w2

      sets:

      *  W1 to the value "Easy come"

      *  W2 to the value " easy go".

      The parser removes the pattern itself (and only the pattern) from
      the string.  Any remaining input is read into the next variable,
      and so on.

      Another example:

      parse value 'Out of sight, out of mind'
      with s1 ',' w2 w3 w4

      sets:

      *  W2 to the value "out"

      *  W3 to the value "of"

      *  W4 to the value "mind"

      Note that the parser assigns a new value to all variables in a
      template.

      If a variable is followed by another variable, REXX takes a
      special action.  REXX skips over leading blanks at the current
      position in the input data before it searches for the next blank.
      The value it assigns to the lefthand variable is the next word in
      the string, with no leading or trailing blanks.  For example, the
      template:

      w1  w2  w3 rest ','

      for the PARSE VALUE instruction with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets:

      *  W1 to the value "This"

      *  W2 to the value "is"

      *  W3 to the value "the"

      *  REST to the value "best mouse"


                                Page [177]

      The final variable, REST, could have both leading and trailing
      blanks, since REXX removes only the blank that delimits the
      previous word.

      This is not the same as specifying explicit blanks as patterns.
      For example, the template:

      w1 ' ' w2 ' ' w3 ' ' rest ','

      for the PARSE VALUE instruction with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets:

      *  W1 to the value "This"

      *  W2 to the value "is"

      *  W3 to the value " " (null)

      *  REST to the value "the best mouse"

      W3 is set to null because the third pattern matches the third
      blank in the data.

      Note: The quotes are not part of the value.  The example shows
      them only to indicate leading or trailing blanks.

      In general then, when a variable follows another variable, it
      implies parsing of the input by tokenization into words.


   Parsing with variable patterns

      You can specify the pattern as a variable, by putting the vari-
      able name in parentheses.  The following PARSE VALUE instruction
      has the same effect as specifying the comma as a literal string:

      comma=','
      'Out of sight, out of mind' with w1 (comma) w2 w3 w4

      Another example:

      input="D*type the *5 67"
      parse var input  verb 2 delim +1 string (delim) rest

      sets:

      *  VERB to 'D'

      *  DELIM to '*'

      *  STRING to 'type the'

      *  REST to '5 67'

                                Page [178]

   Running out of pattern matches

      When REXX cannot find a match for a pattern in the input string,
      it "matches" the end of the string.  For example:

      with s1 ',' w2 ',' s3 ',' rest

      for PARSE VALUE instruction with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets:

      *  W1 to the value "This is  the best mouse"

      *  W2 to the value " I think"

      *  W3 to the value "  to buy."

      *  REST to the value " " (null)

      No match was found for the third ',' in the template, and so W3
      was assigned the rest of the string.  REST was assigned a null
      value because the pattern on its left had already reached the end
      of the string.


   Using a placeholder

      A single period acts as a placeholder in a template.  It has
      exactly the same effect as a variable name, except that no vari-
      able is set.  You can use a period as a "dummy variable" in a
      list of variables, to collect unwanted information at the end of
      a string.  For example:

       . . . word5 .

      extracts the fifth word ('mouse') from the sample string and
      places it in the variable WORD5.


   Parsing with numeric patterns

      A numeric pattern works the same as a string pattern, except you
      specify a column number.  For example, you could use a numeric
      pattern to extract data from particular columns of a record read
      from a file.  For example:

      'Nothing will come of nothing' with x1 5 x2

      splits the string at column 5, and sets:

      *  X1 to the value "Noth"

      *  X2 to the value "ing will come of nothing"


                                Page [179]

      The numeric pattern can be relative to the last number used.  For
      example:

      'Nothing will come of nothing' with x1 5 x2 +5 x3

      has exactly the same effect as the last example, here the "+5"
      specifies the length of the string to be assigned to X2.

      You can mix string patterns and numeric positions (in effect the
      beginning of a string pattern just specifies a variable column
      number).  This lets you do some very complex parsing with
      templates.


   Parsing with positional patterns

      You can use positional parameters to parse a string based on a
      position within the string, rather than on its contents.

      You can use an unsigned number in a template to specify a partic-
      ular character column in the input.  For example, the template

      s1 10 s2 20 s3

      with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets

      *  S1 to the value "This is  "

      *  S2 to the value "the best m"

      *  S3 to the value "ouse, I think, to buy."

      The parser assigns S1 the characters from the first through the
      ninth character, and assigns S2 the characters 10 through 19.
      The final variable S3 is set to the remainder of the input.


   Parsing with relative patterns

      You can use signed numbers as patterns to indicate movement rela-
      tive to the character position at which the previous pattern
      match occurred.

      If you specify a signed number, REXX calculates the position for
      the next match by adding (or subtracting) the number given to the
      last matched position.  The last matched position is the position
      of the first character of the match, specified numerically or by
      a string.  For example, the instructions:

      a = '123456789'
      parse var a 3 s1 +3 s2 3 s3


                                Page [180]

      sets

      *  S1 to the value "345"

      *  S2 to the value "6789"

      *  S3 to the value "3456789"

      The +3 in this example is the same as the absolute number 6 in
      the same position, and works the same as if you assign the length
      of the data string to the variable S1.

      This example also shows the effects of a relative pattern that
      implies movement to a character position to the left of (or to)
      the point at which the last match occurred.  REXX assigns charac-
      ters to the variable on the left through the end of the input,
      and assigns characters to the variable on the right starting at
      the position dictated by the pattern.

      This lets you make multiple assignments.  For example:

      parse var y x1 1 x2 1 x3

      sets X1, X2, and X3 to the entire value of Y.

      If a positional pattern specifies a column that is greater than
      the length of the data, it is the same as specifying the end of
      the data, and no padding takes place.  Similarly, if a pattern
      specifies a column to the left of the first column of the data,
      it is the same as specifying the first column of the data.

      A relative positional pattern can refer to the "last position" in
      a string.  The last position is set to the position in the data
      of the first character in the pattern where the match occurred.
      For example:

      ',' -3 x *=1

      will:

      1. Find the first comma in the input (or the end of the string if
         there is no comma).

      2. Back up three positions.

      3. Assign one character (the character immediately preceding the
         comma or end of string) to the variable X.

      You can use this type of parsing to look for abbreviations in a
      string.  For example, the instruction:

      parse upper value ' 'note with ' CU' +1 charg ' '

      sets the variable CHARG to the first word in NOTE that starts
      with "CU" or sets it to null if no such word exists.


                                Page [181]

      Notes:

      1. The positional pattern +0 is valid, and you can use it to
         include the whole of a previous literal (or variable) pattern
         within the data string to be parsed into any following vari-
         ables.

      2. As the last example shows, patterns can follow each other in
         the template without intervening variable names.  In this
         case, each pattern is used in turn from left to right, as
         usual.

      3. If a number in a template is preceded by a +  or a  - , REXX
         recognizes it as a signed positional pattern.  There can be
         blanks between the sign and the number, since REXX removes
         blanks adjacent to special characters.


   Parsing More Than One String

      A parsing template can parse more than one string.  For example,
      an internal function or subroutine can have more than one argu-
      ment string.  To access each string in turn, use a comma in the
      parsing template.  Each comma instructs the parser to move on to
      the next string.

      Multiple strings are used only with the ARG (or PARSE ARG)
      instruction.  For example:

      date('The date is December 31' ,7)
      parse arg first, second

      sets:

      *  FIRST to the value 'The date is December 31'

      *  SECOND to the value 7

      Between the commas you can put any normal template with patterns
      (and so on) to do more complex parsing on each of the argument
      strings.

      Another example is:

      arg word1 rest1, string2, num

      sets the first word of the first argument string into the vari-
      able WORD1, the rest of that string into REST1, and the next two
      strings into STRING2 and NUM.  If it runs out of strings, REXX
      sets the unused variables to null.







                                Page [182]




                               Chapter 11.
                            Numerics and Math




      REXX arithmetic follows conventional rules to perform arithmetic
      operations.  The rules are defined so that a program can run on
      different hardware architecture and always produce the same
      result.

      Numbers follow conventional syntax, allowing great flexibility.
      REXX permits leading and trailing blanks, and exponential nota-
      tion.

      The arithmetic operators include addition, subtraction, multipli-
      cation, power, division, integer division, and remainder.


   Numbers

      A number is a character string that includes one or more decimal
      digits, with an optional decimal point.  Some valid numbers are:

      25     An integer or whole number

      .5     A decimal or decimal fraction (one-half).  Equal to 0.5.

      -8     A signed number (minus 8)

      5E6    Floating point number (five million) using exponential
             notation.  The number following the E specifies how many
             places to move the decimal point to the right to make it a
             regular number.

      For a decimal number, you can embed the decimal point in the
      digits, or you can use it as a suffix or prefix.  The group of
      digits (and optional point) can have leading or trailing blanks,
      and an optional sign ("+" or "-"), which must come before any
      digits or decimal point.  The sign can also have leading or
      trailing blanks.

      ÄÂÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÂÄdigitsÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÂÄÄÄÄÄ
         ÀblanksÙ ÀsignÄÂÄÄÄÄÄÄÂÙ ÃÄdigits.digitsÄ´ ÀblanksÙ
                        ÀblanksÙ  ÃÄ.digitsÄÄÄÄÄÄÄ´
                                  ÀÄdigits. ÄÄÄÄÄÄÙ

      Where:

      sign   Either "+" or "-"

      blanks One or more spaces


                                Page [183]

      digits One or more numeric characters (0 through 9)

      Note:  A single period alone is not a valid number.


   Precision

      You can control the maximum number of significant digits that
      result from an operation by using the NUMERIC DIGITS instruction.
      For example:

      ÄNUMERIC DIGITSÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                        ÀÄexpressionÄÙ

      REXX resolves the expression, which must result in a positive
      whole number.  This defines the precision to which REXX carries
      out calculations.  REXX rounds all results to that precision.
      If you do not specify an expression, the default precision is 9
      digits.


   Operators

      The arithmetic operators are:

         Addition  +
         Subtraction  -
         Multiplication  *
         Power  **
         Division  /
         Integer division  %
         Remainder  //

      All operations produce results that REXX rounds, if necessary, to
      the precision specified by the NUMERIC DIGITS instruction.

      An operation does not introduce any errors during the operation
      itself except during the final rounding for the result.  REXX
      first truncates the input terms to each operation to the maximum
      number of significant digits, determined by the setting of the
      NUMERIC DIGITS instruction +1 before it computes them.  It then
      carries out the operation up to double that precision, as
      required.

      REXX performs rounding in the "traditional" manner, in that it
      inspects the extra digit, rounds up values of 5 through 9, and
      rounds down values of 0 through 4.

      REXX supplies a conventional zero before a decimal point if
      otherwise there would be no digit preceding it. REXX retains
      significant trailing zeros for addition, subtraction, and multi-
      plication, according to the arithmetic combination rules, except
      that it always expresses a result of zero as the single character
      '0'.  For division, REXX removes trailing zeros after rounding.



                                Page [184]

      If you find that the default format for a number is not satisfac-
      tory for a particular application, use the FORMAT built-in func-
      tion to control its format.  See page 121.

   Examples

      /* With NUMERIC DIGITS 5 */
      12+7.00     @ 19.00
      1.3-1.07    @ 0.23
      1.3-2.07    @ -0.77
      1.20*3      @ 3.60
      7*3         @ 21
      0.9*0.8     @ 0.72
      1/3         @ 0.33333
      2/3         @ 0.66667
      5/2         @ 2.5
      1/10        @ 0.1
      12/12       @ 1
      8.0/2       @ 4


   Arithmetic combination rules

      This section describes the rules the four basic operators used to
      combine two numbers.  REXX removes insignificant leading zeros
      from all numbers, and truncates them to DIGITS+1 digits before
      using them in the computation.


   Addition and subtraction

      REXX extends the numbers on the right and left as necessary and
      are then added or subtracted.  For example:

                xxx.xxx + yy.yyyyy

      becomes:

               xxx.xxx00
            +  0yy.yyyyy
               _________
               zzz.zzzzz

      REXX then rounds the result to the number of digits set by the
      NUMERIC DIGITS instruction if necessary, and removes any insig-
      nificant leading zeros.


   Multiplication

      REXX multiplies the numbers together, using "long multiplica-
      tion".  The result can be as long as the sum of the lengths of
      the operands.  For example:

                xxx.xxx * yy.yyyyy


                                Page [185]

      becomes:

                zzzzz.zzzzzzzz

      REXX then rounds the result to the number of digits set by the
      NUMERIC DIGITS instruction.


   Division

      Before the division, REXX extends the dividend to be at least as
      long as the divisor, taking note of the change in the power of
      ten that this implies.  For example, the division:

             aaa / bbbbb

      becomes:

                   ÚÄÄÄÄÄÄÄ
             bbbbb ³ aaa00

      REXX then performs traditional long division.    During the divi-
      sion, REXX extends the divisor further as necessary.  It then
      extends the quotient to be the same length as the extended divi-
      dend (aaa00 and cccc in the example).

                      cccc
                   ÚÄÄÄÄÄÄÄ
             bbbbb ³ aaa00

      REXX can increase the quotient up to the setting of the NUMERIC
      DIGITS instruction +1 digit, at which point the division stops.
      The quotient will not include any leading zeros.

      REXX rounds the quotient, if necessary, and removes any insignif-
      icant trailing zeros.

      Note: Arithmetic operations do not depend on the position of the
      decimal point.  The results of any operation are completely inde-
      pendent of the number of decimal places in the data.  In fact,
      the operations can be carried out as integer operations with the
      exponent being calculated and applied after.


   Additional operators

      In addition to the traditional operators, REXX defines the power
      ( ** ), integer division ( % ), and remainder ( // ) operators.

      The ** (power) operator raises a number to a whole power, which
      can be positive or negative.  If negative, REXX uses the absolute
      value of the power, and then the inverts the result (divides into
      1).  For calculating the result, REXX effectively multiples the
      number by itself for the number of times expressed by the power,
      and finally removes trailing zeros (as though the result were


                                Page [186]

      divided by one).  In practice, REXX uses left-to-right binary
      reduction to calculate the result.

      For example, in the operation "x**n", REXX converts "n" to
      binary, and sets a temporary accumulator to 1.  If "n" has the
      value 0, the calculation is complete.  Otherwise, REXX inspects
      each bit (starting at the first nonzero bit) from left to right.
      If the current bit is 1, the calculation is complete, otherwise
      it squares the accumulator and inspects the next bit for multi-
      plication.  When the calculation is complete, the temporary
      result is ready for division by or into 1 to provide the final
      answer.  The multiplications and division are done under the
      normal REXX arithmetic combination rules.

      The % (integer divide) operator divides two numbers and returns
      the integer part of the result, which is not rounded unless the
      integer has more digits than the current setting of the NUMERIC
      DIGITS instruction.  The result returned is that which would
      result from repeatedly subtracting the divisor from the dividend
      while the dividend is larger than the divisor.  During this
      subtraction, REXX uses the absolute values of both the dividend
      and the divisor: the sign of the final result is the same as that
      which would result if normal division were used.  Note that this
      operator might not give the same result as truncating normal
      division (which could be affected by rounding).

      The // (remainder) operator returns the remainder from integer
      division, and is defined as being the residue of the dividend
      after the operation of calculating integer division.  The sign of
      the remainder, if nonzero, is the same as that of the original
      dividend.

   Examples

      /* With NUMERIC DIGITS 5 */
      2**3                @ 8
      2**-3               @ 0.125
      1.7**8              @ 69.758
      2%3                 @ 0
      2.1//3              @ 2.1
      10%3                @ 3
      10//3               @ 1
      -10//3              @ -1
      10.2//1             @ 0.2
      10//0.3             @ 0.1
      3.6//1.3            @ 1.0


   Comparing Numbers

      You can use any of the comparative operators to compare numeric
      strings.  However, the strict comparative operators are not
      numeric comparison operators and should not normally be used for
      comparing numbers, since leading and trailing blanks (and leading
      zeros) are significant for these operators.


                                Page [187]

      When REXX compares numbers, it first subtracts the two numbers
      according to its subtraction rules and then compares the result
      with '0'.  For example, the operation:

      A ? B

      Where "?" is any numeric comparison operator, is identical to:

      (A - B) ? '0'

      Therefore, REXX uses the difference between two numbers to deter-
      mine their equality.

      You can specify the amount by which two numbers can differ before
      being considered equal for the purpose of comparison.  This is
      called the fuzz value.  The fuzz value is set by the instruction:

      ÄNUMERIC FUZZÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ;ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                       ÀÄexpressionÄÙ

      The expression must result in a whole number that is zero or
      positive.  The default is 0.

      The NUMERIC FUZZ instruction temporarily reduces the value of
      NUMERIC DIGITS by the NUMERIC FUZZ value for each comparison
      operation.  The numbers are subtracted under a precision of
      DIGITS-FUZZ digits during the comparison.  Therefore, the NUMERIC
      FUZZ setting must be less than the setting of NUMERIC DIGITS.

      For example, if DIGITS = 9, and FUZZ = 1, REXX carries out the
      comparison to 8 significant digits, just as though "NUMERIC
      DIGITS 8" had been in effect for the operation.

   Example

      1 numeric digits 5
      2 numeric fuzz 0
      3 say  4.9999 = 5
      4 say  4.9999 < 5
      5 numeric fuzz 1
      6 say  4.9999 = 5
      7 say  4.9999 < 5

        3:Displays 0
        4:Displays 1
        6:Displays 1
        7:Displays 0


   Exponential notation

      So far this section has described "pure" numbers.  Although char-
      acter strings that describe numbers can be very long, REXX lets
      you specify a number using exponential notation.  This makes it
      easier to work with both large and small numbers.  In extreme
      cases, exponential notation is needed to make execution possible.

                                Page [188]

      REXX uses exponential notation whenever the "pure" form would
      give misleading information.  For example:

      numeric digits 5
      say 54321*54321

      would type "2950800000" if the long form were used.  This is
      clearly misleading, so REXX would express the result in exponen-
      tial notation, in this example "2.9508E+9".

      This extends the definition of numbers by the following:

      ÄÄÂÄdigitsÄÄÄÄÄÄÄÄÂÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
          ÃÄdigits.digitsÄ´ ÀÄEÄÂÄÄÄÄÄÄÂÄdigitsÄÙ
          ÃÄ.digitsÄÄÄÄÄÄÄ´     ÀÄsignÄÙ
          ÀÄdigits. ÄÄÄÄÄÄÙ

      In other words, you can follow the numeric part of a number by an
      "E" (to indicate exponential notation), an optional sign, and an
      integer following the "E" (or sign) to represents a power of ten
      to apply.  The "E" can be in upper or lower case.  You cannot use
      blanks within this numeric part of a number.

      The following are examples:

      12E11  =  1200000000000
      12E-5  =  0.00012
      -12e4  =  -120000

      You can use all valid numbers as data for arithmetic.  The
      results will be returned in exponential form depending on the
      setting of the NUMERIC DIGITS instruction.  If the number of
      places needed before the decimal point exceeds NUMERIC DIGITS, or
      if the number of places after the point exceeds twice NUMERIC
      DIGITS, REXX uses exponential notation.  The exponential form
      REXX always has a sign following the "E" to improve readability.
      If the exponent is 0, REXX omits the exponential part - that is,
      it will never generate an exponential part for "E+0".

      If you find that the default format for a number is not satisfac-
      tory for a particular application, use the FORMAT built-in func-
      tion to control its format.  The FORMAT function can explicitly
      convert numbers to exponential form or return numbers in "pure"
      form.  See page 121.

      You can also select different exponential forms with the NUMERIC
      FORM instruction, for example, either scientific or engineering
      notation.  Scientific notation adjusts the power of ten so there
      is a single nonzero digit to the left of the decimal point.
      Engineering notation expresses powers of ten as a multiple of 3 -
      the integer part can therefore range from 1 through 999.  The
      default is scientific.

      For example:



                                Page [189]

      numeric form scientific
      say 123.45 * 1e11
      /* displays:     1.2345E+13  */

      numeric form engineering
      say 123.45 * 1e11
      /* displays:     12.345E+12  */


   Use of numbers by REXX

      Whenever REXX uses a character string as a number (for example as
      an argument to a built-in function, or from the result of an
      expression in a DO clause) rounding might occur according to the
      setting of the NUMERIC DIGITS instruction.


   Errors

      The errors that might occur during arithmetic are:

      *  41 - Bad arithmetic conversion

         Occurs if one of the terms involved in an arithmetic operation
         is not a valid number, or its exponent exceeds 9 digits.

      *  42 - Arithmetic overflow/underflow

         Occurs if the exponential part of a result exceeds 999999999
         or is less than -999999999.

         REXX considers this a terminating error, rather than an arith-
         metical error.

      *  5 - System resources exhausted

         REXX needs storage for calculations and intermediate results,
         and on occasion an arithmetic operation might fail due to lack
         of storage.  REXX considers this a terminating error as usual,
         rather than an arithmetical error.

















                                Page [190]




                               Chapter 12.
                             Input and Output




      In most circumstances, a user communicates with a REXX program
      using the standard character input and output streams.  The
      communication to or from the user usually consists of a stream of
      characters.

      *  A character input stream is a serial character stream that is
         either generated by the user, or has the characteristics of a
         stream that is generated by the user.

      *  A character output stream is a serial character stream that
         accepts output from a REXX program.

      Other sources or destinations such as files, serial interfaces,
      displays, or networks can also use the standard character streams
      to communicate with REXX.    The character streams can be tran-
      sient (for example, data sent or received over a serial inter-
      face) or persistent (for example, files and objects).

      In addition, you can use the external data queue to communicate
      between programs.

      *  The external data queue is a queue of character strings.  The
         character strings are arbitrary and have no special meaning or
         effect.

      The external data queue is, by default, the SESSION queue which
      is unique to each session and is accessible only to its related
      processes.  A program may create and delete queues and switch the
      external data queue to another queue name.  A created queue
      persists until it is explicitly deleted and may be accessed
      concurrently by multiple programs across multiple sessions.
      Apart from the instructions and functions described in this
      section, executing a REXX program does not affect the queue,
      except when control leaves the program (for example, when an
      external command or routine is called).  The queues form a
      language-defined channel of communication between programs.

      When you read from or write to a file, you must be consistent
      when you specify the file name.  For example, if you use a path
      prefix with a file name, you must use it the next time you
      specify the file name, or you will get unpredictable results.  An
      easy way to be consistent is to assign the file name to a vari-
      able, and use the variable each time you refer to the file.

      You can specify hardware devices with the I/O routines instead of
      file names.  For example, if you specify PRN as the output file,
      REXX prints the input file.

                                Page [191]

      REXX performs any necessary housekeeping (e.g., opening and
      closing files) for character streams automatically.


   Manipulating character streams

      You can use REXX instructions and built-in functions to manipu-
      late the character streams.  For the more general input and
      output streams, you can specify a name for a stream.

      You can manipulate the character input and output streams either
      character-by-character or line-by-line.  However, you can only
      manipulate the external data queue line-by-line.


   Manipulating input streams

      The following instructions and functions manipulate the input
      stream:

      CHARIN

         Reads one or more characters from a character input stream.
         You can specify a start position for persistent streams.
         Function, see page 96.

      CHARS

         Returns the number of characters currently remaining in a
         character input stream from the read position through the end
         of the stream (including all line-end characters).  Function,
         see page 100.

      LINEIN

         Reads one line from a character input stream.  You can specify
         a line number for persistent streams.  Function, see page 128.

      LINES

         Returns the number of complete lines currently remaining in a
         character input stream.  Function, see page 132.

      PARSE LINEIN

         Reads one line from the default character input stream,
         regardless of the status of the external data queue.  Instruc-
         tion, see page 56.


   Manipulating output streams

      The following instructions and functions manipulate the output
      stream:



                                Page [192]

      CHAROUT

         Writes zero or more characters to a character output stream.
         This function usually provides complete control over the
         output stream.  You can specify a start position for
         persistent streams.  Function, see page 98.

      LINEOUT

         Writes one line to a character output stream.  Implies an
         appropriate line-end sequence at the end of each line.  You
         can specify a line number for persistent streams.  Function,
         see page 130.

      SAY

         Writes one line to the default character output stream.
         Implies an appropriate line-end sequence at the end of each
         line.  Instruction, see page 65.


   Manipulating the external data queue

      The following instructions and functions manipulate the external
      data queue:

      PARSE PULL

         Reads one line from the external data queue.  If the queue is
         empty, it reads a line from the default character input stream
         instead.  This lets you use the external data queue as a
         source for user input, provided that the user input is read as
         lines with these instructions.  Instruction, see page 56.

      PULL

         Performs the same function as PARSE PULL, except that it
         translates the string to upper case.  Instruction, see page
         61.

      PUSH

         Writes one line to the head of the external data queue, as in
         a stack.  Instruction, see page 62.

      QUEUE

         Writes one line to the tail of the external data queue.
         Instruction, see page 63.

      QUEUED

         Returns the number of lines currently available in the
         external data queue.  Function, see page 138.



                                Page [193]

   Input/Output Examples

   Example

      Display a file, with line numbers

      1 parse upper arg InFile leftover
      2 InPath = STREAM(InFile,'C','QUERY EXIST')
      3 if InPath = '' then do
      4    say "File not found" InFile
      5    exit
      6 end
      7 say "Reading file" InPath
      8 say " "
      9 LineNumber = 0
      10do while LINES(InFile) > 0
      11   Text = LINEIN(InFile)
      12   LineNumber = (LineNumber + 1)
      13   Number = right(LineNumber,4,'0')
      14   say Number Text
      15end
      16exit

        1:Get command line arguments
        2:Check that file exists
        3:If the file was not found,
        4:Display error message
        5:And exit this program.
        7:Display path & file name.
        9:Initialize line counter.
        10:While not at end of file,
        11:Read one line, then
        12:Increment our line number,
        13:Format with leading zeros,
        14:And display number & line.
        16:Exit this program.

   Example

      Display file information

      1 parse upper arg InFile leftover
      2 InPath = STREAM(InFile,'C','QUERY EXIST')
      3 if InPath = '' then do
      4    say "File not found" InFile
      5    exit
      6 end
      7 Date = STREAM(InFile,'C','QUERY DATETIME')
      8 Size = STREAM(InFile,'C','QUERY SIZE')
      9 say "File path =" InPath
      10say "File date =" Date
      11say "File size =" Size
      12exit

        1:Get command line arguments.
        2:Check that file exists

                                Page [194]

        3:If the file was not found,
        4:Display a message,
        5:Then exit this program.
        7:Get the file's date & time.
        8:Get the file's size.
        9:Display drive+path+filename.
        10:Display file's date & time.
        11:Display file's size.
        12:Exit this program.

   Example

      Make a copy of a file

      1 parse upper arg InFile OutFile leftover
      2 InPath  = STREAM(InFile,'C','QUERY EXIST')
      3 OutPath = STREAM(OutFile,'C','QUERY EXIST')
      4 if InPath = '' then do
      5    say "The file" InFile "was not found."
      6    exit
      7 end
      8 if OutPath \= '' then do
      9    say "The file" OutFile "already exists."
      10   exit
      11end
      12say "Copying" InFile "to" OutFile
      13do while CHARS(InFile) > 0
      14   OneChar = CHARIN(InFile)
      15   call CHAROUT OutFile, OneChar
      16end
      17call CHAROUT OutFile
      18exit

        1:Get command line arguments.
        2:Check for existing in file.
        3:Check for existing out file.
        4:If input file not found,
        5:Display an error message.
        6:Then, exit this program.
        8:If out file already exists,
        9:Give a warning message.
        10:Then, exit this program.
        12:Display upcoming operation.
        13:Do loop until end of file.
        14:Read one character, then
        15:Write the character.
        17:Close the output file.
        18:Exit this program.









                                Page [195]

   Example

      Read data from a queue

      1 Newq = RXQUEUE('Create', 'QFOO')
      2 Oldq = RXQUEUE('Set', Newq )
      3
      4 do until Qline = '!!'
      5    Qline = linein('QUEUE:')
      6    say Qline
      7 end
      8
      9 call RXQUEUE 'Set' Oldq
      10rc = RXQUEUE('Delete', Newq )
      11if rc \= 0 then
      12   say 'Error 'rc 'deleting' Newq
      13
      14exit rc

        1:Create QFOO.
        2:Select QFOO as the external data queue.
        4:Until Qline = '!!'.
        5:Read from the data queue.
        6:Display the line read from the queue.
        9:Reselect the original queue.
        10:Delete the queue which was created.
        11:Check the return code for errors.
        12:Display error message.
        14:Exit this program.




























                                Page [196]




                               Chapter 13.
                             Condition Traps




      One important use of the instructions CALL and SIGNAL is to
      detect certain REXX program errors. The program errors these
      instructions can detect are called condition traps. See CALL page
      33 and SIGNAL page 68.

      When REXX encounters either a CALL ON condition or a SIGNAL ON
      condition instruction, it sets a condition trap.  The default is
      off.

      The following conditions trap command failures:

      ERROR    Any host command returns a nonzero return code.  Or, a
               command fails and CALL ON FAILURE or SIGNAL ON FAILURE
               has not been set.  The condition occurs at the end of
               the clause that invoked the command.  It is ignored if
               the ERROR condition trap is already in the delayed
               state.  The delayed state temporarily suspends the
               condition trap, but keeps track of the fact that it has
               occurred.  See page 198.

               For the default CMD processor, all nonzero return codes
               from programs raise this condition.  However, this might
               or might not happen in other subcommand environments.

      FAILURE  Any host command indicates a failure upon return.  The
               condition occurs at the end of the clause that invoked
               the command.  It is ignored if the FAILURE condition
               trap is already in the delayed state.  The delayed state
               temporarily suspends the condition trap, but keeps track
               of the fact that it has occurred.  See page 198.

               This condition also occurs for the default CMD proces-
               sor, if REXX tries to issue an unknown command.  It also
               occurs if REXX tries to issue a command to an unknown
               subcommand environment; in this case, the variable RC is
               set to 2, which is the system return code for "File Not
               Found".  Other environments might issue different codes
               for this condition.

      The following conditions trap other errors:

      HALT     Program execution is interrupted externally.  For exam-
               ple, pressing Ctrl-C to interrupt the program.

      NOTREADY REXX encountered an error during an input or output
               operation.  See "Input and Output" on page 191.


                                Page [197]

      NOVALUE  The program used an uninitialized variable.  The vari-
               able is used as:

               *  The name following the VAR subkeyword of the PARSE
                  instruction

               *  A term in an expression

               *  An unassigned variable pattern in a parsing template

                  You can only specify this condition for SIGNAL ON.

      SYNTAX   REXX detected an interpretation error.    You can only
               specify this condition for SIGNAL ON.


   What Happens When a Condition is Trapped

      When the condition specified with a CALL or SIGNAL instruction
      occurs, REXX passes control to a label or routine.  The label or
      routine depends on whether you used the trapname option when you
      turned on the condition trap:

      *  If you did not specify a trapname, REXX passes control to the
         label or routine that matches the name of the condition:
         ERROR, FAILURE, HALT, NOVALUE, NOTREADY, or SYNTAX.

      *  If you specified a trapname, REXX passes control to that label
         or routine.

      When REXX traps a condition, the action it takes depends on
      whether a SIGNAL or CALL is executed:

      *  If a SIGNAL is executed, the current instruction stops
         executing immediately, the condition is turned off, and the
         SIGNAL instruction executes as usual.  See page 68.

         If you want to trap any new occurrence of the condition, you
         must issue a new CALL ON or SIGNAL ON instruction for the
         condition.  For example, if you enable SIGNAL ON SYNTAX when a
         SYNTAX condition occurs, and REXX does not find the SIGNAL ON
         SYNTAX label name, it issues a normal syntax error and termi-
         nates.

      *  If a CALL is executed, it works as usual, except that the
         special variable RESULT is not affected by the call.  If the
         routine returns any data, the returned character string is
         ignored.

         CALL ON can only occur at clause boundaries.  Because the
         conditions ERROR, FAILURE, and HALT can arise during execution
         of an INTERPRET instruction, execution of the INTERPRET can be
         interrupted and later resumed if you use CALL ON.

         Before the CALL is made, the condition trap is put into a
         delayed state.  The delayed state prevents a premature condi-

                                Page [198]

         tion trap at the start of the routine called to process a
         condition trap.  The state remains in effect until the return
         from the CALL, or until you specify an explicit CALL (or
         SIGNAL) ON (or OFF) for the condition.  When a condition trap
         is in the delayed state, it remains enabled, but if the condi-
         tion is trapped again, any action (including the updating of
         the condition information) is delayed until:

         1. You execute a CALL ON or SIGNAL ON for the delayed condi-
            tion.  In this case, a CALL or SIGNAL takes place immedi-
            ately after the new CALL ON or SIGNAL ON instruction
            executes.

         2. You execute a CALL OFF or SIGNAL OFF for the delayed condi-
            tion.  In this case, the condition trap is disabled and the
            default action for the condition occurs at the end of the
            CALL OFF or SIGNAL OFF instruction.

         3. A RETURN is made from the subroutine.  In this case, the
            condition trap is no longer delayed and the subroutine will
            be called again immediately.

            On RETURN from the CALL, the original flow of execution is
            resumed; the flow is not affected by the CALL.

   Remarks

      1. REXX saves the state (ON, OFF, or DELAY) and any trapname of
         each condition trap on entry to a subroutine without affecting
         the conditions set up by the caller.  See the CALL instruction
         on page 33.

      2. An external routine invoked by a CALL does not affect the
         state of condition traps, even if the external routine is a
         REXX program.    On entry to any REXX program, all condition
         traps have an initial setting of OFF.

      3. Whenever an event occurs that corresponds to an enabled condi-
         tion, the current instruction terminates and the condition is
         raised immediately.  This means that if an event occurs during
         an instruction, the instruction might not complete execution.
         For example, if SYNTAX is raised during the evaluation of the
         expression in an assignment, the assignment does not take
         place.  Note that ERROR, FAILURE, and HALT can only occur at
         clause boundaries, but could arise in the middle of an
         INTERPRET instruction.

      4. All condition traps are turned off during interactive tracing.
         This prevents any unexpected transfer of control while the
         user is debugging the program.  Also, if a syntax error occurs
         during interactive tracing, it will not cause an exit from the
         program, but is trapped specially and then ignored after a
         message is given.

      5. Labels are clauses consisting of a single symbol followed by a
         colon.  Any number of successive clauses can be labels; there-

                                Page [199]

         fore multiple labels are allowed before another type of
         clause.


   Condition Information

      When REXX traps any condition, it records information about that
      condition.  The condition information includes:

      *  The name of the current trapped condition

      *  Any descriptive string associated with that condition

      *  The instruction executed as a result of the condition trap
         (CALL or SIGNAL)

      *  The status of the trapped condition.

      To retrieve this information, use the CONDITION built-in func-
      tion.  See page 102.

      The descriptive string varies, depending on the condition
      trapped.  In the case of SIGNAL, the descriptive string that is
      passed to the external environment as a command results in one of
      the following:

      ERROR    The string that was processed and resulted in the error
               condition.

      FAILURE  The string that was processed and resulted in the
               failure condition.

      HALT     Any string associated with the halt request.  This can
               be the null string if no string was provided.

      NOTREADY The name of the stream being manipulated when the error
               occurred and the NOTREADY condition was raised.

      NOVALUE  The derived name of the variable whose attempted refer-
               ence caused the NOVALUE condition.

      SYNTAX   Any string associated with the interpretation error.
               This can be the null string if no specific string is
               provided.  The special variables RC and SIGL provide
               information on the nature and position of the processing
               error.

      The current condition information is replaced when control is
      passed to a label as the result of a condition trap (CALL ON or
      SIGNAL ON).  Condition information is saved and restored across
      subroutine or function calls, including one due to a CALL ON
      trap.  A routine invoked by a CALL ON, therefore, can access the
      appropriate condition information.  Any previous condition infor-
      mation is still available after the routine returns.



                                Page [200]

   Error and line number information

      REXX stores the program line number of the SIGNAL (or CALL)
      instruction that caused a jump in the special variable SIGL.
      This is useful for SIGNAL ON SYNTAX because you can use the
      number of the line in error to control an editor.  For example,
      the code that follows the SYNTAX label could issue the PARSE
      SOURCE instruction to find the source of the data, then invoke an
      editor to edit the source file, positioned at the line that
      caused the error.  However, you must reinvoke the program before
      any changes made in the editor can take effect.

      For ERROR and FAILURE, the REXX special variable RC is set to the
      command return code error number before control is transferred to
      the condition label.  For SIGNAL ON SYNTAX, RC is set to the
      syntax error number.


   Condition Trap Example

   Example

      Loop until oCTRLpoCp is pressed.

      /*  REXX */

      CALL ON HALT NAME HaltTrap

      SAY 'Press Ctrl-C to quit'

      QUIT = 0

      DO WHILE QUIT = 0
      END

      EXIT


      HaltTrap:

         SAY 'Execution interrupted'
         QUIT = 1
         RETURN














                                Page [201]




                               Appendix A.
                                 Messages




      If REXX detects an error in a program, it displays one of the
      following error messages.  You can trace errors using the TRACE
      instruction, and you can trap and test them using the SIGNAL ON
      SYNTAX instruction.

      This appendix lists all REXX error messages numerically and gives
      an explanation of each message, as well as some suggestions for
      recovering from errors.


      4 - Program interrupted

      The system interrupted a REXX program because of an error, or by
      user request.  Unless trapped by SIGNAL ON HALT, this error stops
      a REXX program immediately.


      5 - System resources exhausted

      REXX could not get enough space for its work areas and variables,
      and therefore cannot execute the program.  This error might occur
      because the program that invoked REXX has already used up most of
      the available storage.


      6 - Unmatched "/*" or quote

      REXX reached the end of the file (or the end of data in an
      INTERPRET instruction) without finding the ending  */  for a
      comment or quote for a literal string.


      7 - WHEN or OTHERWISE expected

      Within a SELECT construct, REXX expects at least one WHEN
      construct (and possibly an OTHERWISE clause).  This message is
      issued when either any other instruction is found, or no WHEN
      construct is found before the OTHERWISE, or if all WHEN expres-
      sions are found to be false and an OTHERWISE is not present.

      Check to make sure that you did not forget the DO and END around
      the list of instructions following a WHEN.  For example:

      THE WRONG WAY            THE RIGHT WAY
      select                   select
         when d=e then            when d=e then
            say 'D equals E'         DO

                                Page [202]

            exit                        say ' D equals E'
         otherwise not                  exit
      end                            END
                                  otherwise nop
                               end


      8 - Unexpected THEN or ELSE

      A THEN or an ELSE does not match a corresponding IF (or WHEN)
      clause.  Check to make sure that you did not forget the END or
      DO...END in the THEN part of a complex IF...THEN...ELSE construc-
      tion.  For example:

      THE WRONG WAY            THE RIGHT WAY
      if d=e then              if d=e then
         DO                       DO
            say `EQUALS'             say `EQUALS'
            exit                     exit
      else                        END
         say `NOT EQUALS'      else
                                  say `NOT EQUALS'


      9 - Unexpected WHEN or OTHERWISE

       A WHEN or an OTHERWISE is outside of a SELECT construct.  You
      might have enclosed the instruction unintentionally in a DO...END
      construct by leaving off an END instruction; or you might have
      tried to branch to it with a SIGNAL instruction (which cannot
      work, as a SIGNAL terminates a SELECT).


      10 - Unexpected or unmatched END

      The program contains more ENDs than DOs and SELECTs, or the ENDs
      are placed so that they do not match the DOs and SELECTs.

      This message is raised if you place an END immediately after a
      THEN or ELSE construction.  It might also help to locate the
      error if you put the name of the control variable on ENDs that
      close repetitive loops.


      11 - Control stack full

      The program exceeds the nesting level limit of 250 for control
      structures (DO...END, IF...THEN...ELSE, and so forth).

      This could be a looping INTERPRET instruction, for example:

      line=`INTERPRET line'
      INTERPRET line

      These lines would loop until they exceeded the nesting level
      limit of 250, and REXX would issue the message.    Similarly, a

                                Page [203]

      recursive subroutine that does not terminate correctly could loop
      until REXX issues this message.


      12 - Clause > 250 tokens

      The program exceeds the 250 token limit on the length of the
      internal representation of the clause.

      Your program might have a missing quote, which caused REXX to
      include several lines in one long string.  Check the output that
      is flagged by + + + to find the start of the problem.  Also check
      for lines terminated by the continuation character ",".


      13 - Invalid character in program

      The program includes a character outside of a literal (quoted)
      string that is not a blank or one of the following:

      A-Z a-z 0-9        (alphanumerics)
      ?  !  .  -  $   # @  (name characters)
      & * ( ) - + =      (special characters)
      ` " ; : < , > / \ | ª  %


      14 - Incomplete DO/SELECT/IF

      REXX has reached the end of the file (or the end of data for an
      INTERPRET instruction), and has found that there is a DO or
      SELECT without a matching END, or an IF that is not followed by a
      THEN clause.  To make it more obvious where the missing END
      should be, use the TRACE Scan instruction to show the structure
      of the program.  You might also want to put the name of the
      control variable on ENDs that close repetitive loops to help
      locate this kind of error.


      15 - Invalid hexadecimal or binary string

      Hexadecimal or binary constants cannot have leading or trailing
      blanks, and can have imbedded blanks at byte boundaries.  Binary
      constants can also have blanks at nibble boundaries (group of
      four digits).

      Check to see if you have mistyped one of the digits.  For exam-
      ple, you might have typed the letter o instead of a 0.  This
      error might also be caused if you follow a string by the
      one-character symbol X (the name of the variable X) when the
      string is not intended to be taken as a hexadecimal specifica-
      tion.  In this case, use the explicit concatenation operator "||"
      to concatenate the string to the value of the symbol.





                                Page [204]

      16 - Label not found

      A SIGNAL instruction has been executed (or an event for which a
      trap was set has occurred), and REXX cannot find the label speci-
      fied in the program.


      17 - Unexpected PROCEDURE

      A PROCEDURE instruction is in an incorrect place.

      A PROCEDURE instruction must be encountered as the result of a
      CALL or function call.  This message is sometimes caused by
      "falling into" an internal routine rather than invoking it with a
      CALL or a function call.


      18 - THEN expected

      Each IF and WHEN clause must be followed by a THEN clause.  REXX
      expected a THEN clause and did not find one.


      19 - String or symbol expected

      REXX expected a symbol to follow the keywords CALL, SIGNAL,
      SIGNAL ON, or SIGNAL OFF, but did not find one.  Check to see if
      you have omitted the string or symbol, or inserted a special
      character.


      20 - Symbol expected

      REXX expected a symbol to follow the clauses CALL ON, END,
      ITERATE, LEAVE, NUMERIC, PARSE, and PROCEDURE or SIGNAL ON.  Or,
      REXX expected a list of symbols to follow the DROP or PROCEDURE
      (with the EXPOSE option) keywords.  Either there was no symbol
      when one was required, or REXX found some other characters.


      21 - Invalid data on end of clause

      Some data other than a comment follows a clause such as SELECT or
      NOP.


      22 - Invalid character string

      A literal string contains character codes that are not supported.


      23 - Invalid data string

      A data string (result of an expression and so on) contains char-
      acter codes that are not valid.  This might be because some char-
      acters are "impossible", or because the character set is extended

                                Page [205]

      in some way and certain character combinations are not allowed.


      24 - Invalid TRACE request

      The setting specified on a TRACE instruction (or as the argument
      to the TRACE built-in function) starts with a character that is
      not one of the valid TRACE settings:  A, C, E, F, I, L, N, O or
      R.


      25 - Invalid subkeyword found

      REXX expected a particular subkeyword at this position in an
      instruction but found something else.  For example, REXX found
      something other than DIGITS, FUZZ, or FORM as the second token in
      the NUMERIC instruction.


      26 - Invalid whole number

      One of the following did not evaluate to a whole number (or eval-
      uated to a whole number that exceeds the limit for these uses):

      *  Positional patterns in parsing template

      *  The power value (right hand operand) of the power operator

      *  The values of exprr and exprf in the DO instruction

      *  The values given for DIGITS or FUZZ in the NUMERIC instruction

      *  Any number used in the option of the TRACE instruction

      REXX also raises this error if it does not permit the value (for
      example, a negative repetitor found in a DO instruction).


      27 - Invalid DO syntax

      A DO instruction contains a syntax error.


      28 - Invalid LEAVE or ITERATE

      A LEAVE or ITERATE instruction is in a wrong position.


      29 - Environment name > 250 characters

      The ADDRESS instruction specifies an environment name that
      exceeds the 250 character limit.





                                Page [206]

      30 - Name or string > 250 characters

      A variable or a literal (quoted) string is longer than the 250
      character limit.  Try breaking the string into two or more
      strings.


      31 - Name starts with a number or "."

      A value cannot be assigned to a variable whose name starts with a
      numeric digit or a period (since if it were permitted, you could
      redefine numeric constants).


      33 - Invalid expression result

      The result of an expression in an instruction is invalid in the
      particular context in which it is used.  This might be due to an
      illegal FUZZ or DIGITS value in a NUMERIC instruction (FUZZ
      cannot become larger than DIGITS).


      34 - Logical value not 0 or 1

      The expression in an IF, WHEN, DO WHILE or DO UNTIL phrase must
      result in a '0' or a '1', as must any term operated on by a
      logical operator:  ª, \, |, &, or &&.


      35 - Invalid expression

      An expression has a grammatical error.  For example, it might end
      with an operator, or have two operators adjacent with nothing in
      between.  Or, a required expression is missing.

      You might have tried to include special characters (such as oper-
      ators) in an intended character expression without enclosing them
      in quotes.


      36 - Unmatched "(" in expression

      An expression contains more left parentheses than right paren-
      theses.


      37 - Unexpected "," or ")"

      A comma is outside a function invocation, or an expression
      contains too many right parentheses.







                                Page [207]

      38 - Invalid template or pattern

      A parsing template contains a special character that is not
      allowed (for example, %), or the syntax of a variable pattern is
      incorrect (that is, no symbol was found after a left parenthe-
      sis).  This error might also be raised if you omit the WITH
      subkeyword in a PARSE VALUE instruction.


      39 - Evaluation stack overflow

      The expression is too complex to be evaluated by REXX.  For exam-
      ple, an expression cannot contain more than 30 nested paren-
      theses.


      40 - Incorrect call to routine

      The specified built-in or external routine does exist, but is
      used incorrectly.  Either the program passes invalid arguments to
      the routine, the program passes more than 30 arguments, or the
      program invoked is not compatible with REXX.


      41 - Bad arithmetic conversion

      One of the terms involved in an arithmetic operation is not a
      valid number, or its exponent exceeds 9 digits.


      42 - Arithmetic overflow/underflow

      The result of an arithmetic operation requires an exponent that
      is greater than 999,999,999 or less than -999,999,999.

      This can happen during evaluation of an expression (commonly an
      attempt to divide a number by 0), or possibly during the stepping
      of a DO loop control variable.


      43 - Routine not found

      REXX cannot find a function that has been invoked within an
      expression (or a subroutine that has been invoked by CALL).  No
      label with the specified name exists in the program, it is not
      the name of a built-in function, and REXX has been unable to
      locate it externally.  The name has probably been mistyped, or it
      is possible that a symbol or literal string is adjacent to a "("
      when you meant to separate it by a blank or some other operator.
      REXX recognizes this as a function invocation.    For example:

      6(7+1)  should be 6*(7+1)





                                Page [208]

      44 - Function did not return data

      An external function has been invoked within an expression, but
      even though it ended without an error, it did not return data.


      45 - No data specified on function RETURN

      The program has been called as a function, but the RETURN
      instruction is attempting to return without passing back any
      data.

      Similarly, if you call an internal routine as a function, you
      must specify an expression on any RETURN instruction you execute
      from the function.


      48 - Failure in system service

      Some system service used by REXX (such as stream input or output,
      or manipulation of the external data queue) has failed and REXX
      cannot continue normal execution.


      49 - Interpretation error

      A severe error has occurred within REXX.


   Extended Return Codes

      The following return codes and messages extend the standard REXX
      return codes, and are specific to REXX.


      200 - Invalid REXX command option

      You tried to enter an invalid REXX command option.    The REXX
      command accepts the following options: -a, -i, -n, -o, or -x.


      201 - Program not found

      The system could not find the main REXX program under the speci-
      fied drive, path, and filename.  Only a search for the main REXX
      program can generate this condition.  When a program calls
      another REXX program and cannot find it, it issues message 43 -
      Routine not found.


      202 - Data too large

      A variable assignment or expression results in data that exceeds
      the REXX limit of 32,700 characters per individual data element.



                                Page [209]

      203 - Program source unavailable

      The REXX program being executed contains only executable object
      code.  The original source to the program is not available.  This
      means you cannot use the built-in function SOURCELINE( ) to
      retrieve a line from the program.


      204 - Calling into DO construct

      A CALL instruction specifies a target label that is located
      within a DO..END instruction block.  Target labels for CALL and
      SIGNAL instructions must be located outside of DO..END
      constructs.  In the case of duplicate labels, this restriction
      applies only to the first occurrence of the label.


      205 - Signalling into DO construct

      A SIGNAL instruction specifies a target label that is located
      within a DO..END construct.  Target labels for SIGNAL and CALL
      instructions must be located outside of DO..END constructs.  If
      duplicate labels exist, this restriction applies only to the
      first occurrence of the label.


      206 - Duplicate label defined

      A label name has already been used.  This is only a warning
      condition.  If duplicate labels exist, CALL and SIGNAL instruc-
      tions always branch to first occurrence of the label.


      207 - Program cannot be accessed

      The REXX program to be executed could not be accessed.  Most
      likely, the program file is currently opened by another process
      that is denying read access from the file.



















                                Page [210]




                               Appendix B.
                            Sample Procedures




   Example

      1 /* Sample Procedure to Change Directories */
      2 ADDRESS CMD
      3 'CD \TEMP'
      4 EXIT

        3:Changes directory to \temp

   Example

      1 /* Sample Procedure to Change Directories */
      2 ADDRESS CMD
      3 SAY 'Enter the New Directory to change to?'
      4 PULL Path
      5 'CD' Path
      6 EXIT

        3:Prompts the user for a new directory
        4:Get the directory name from the User
        5:Change directory

   Example

      1 /* Sample Procedure to Change Directories */
      2 ADDRESS CMD
      3 SAY 'Enter the New Directory to change to?'
      4 PULL Path
      5 PARSE VALUE Path WITH Drive ':' Rest
      6 IF Rest \= '' THEN
      7    DO
      8       Drive = Drive || ':'
      9       Drive
      10   END
      11'CD' Path
      12EXIT

        3:Prompts the user for a new directory
        4:Get the directory name from the user
        5:Parses out the drive letter
        6:If Rest = '' then there was no drive specified
        8:Appends the colon on to the drive
        9:Change drives
        11:Change directory




                                Page [211]

   Example

      1 /* Sample Procedure to Change Directories */
      2 /* Saves the current directory and runs a */
      3 /* program from another directory         */
      4 ADDRESS CMD
      5 SAY 'Enter the New Directory to change to?'
      6 PULL Path
      7 PARSE VALUE Path WITH Drive ':' Rest
      8 IF Rest \= '' THEN
      9    DO
      10      Drive = Drive || ':'
      11      Drive
      12   END
      13'CD' Path
      14SAY 'Enter the Program Name to Run?'
      15PULL Program
      16Program
      17EXIT

        5:Prompts the user for the new directory
        6:Get the directory name from the user
        7:Parses out the drive
        8:If Rest = '' then there was no drive specified
        10:Appends the colon on to the drive
        11:Change drives
        12:Change directory
        13:Prompts the user for the program
        14:Gets input
        15:Runs the program

   Example

      1 /* Sample Procedure to Change Directories */
      2 ADDRESS CMD
      3 SAY 'Enter the New Directory to change to?'
      4 PULL Path
      5 PARSE VALUE Path WITH Drive ':' Rest
      6 IF Rest \= '' THEN
      7    DO
      8       Drive = Drive || ':'
      9       CALL DosDrive Drive;
      10   END
      11CALL DosChDir Path;
      12SAY 'Enter the Program Name to Run?'
      13PULL Program
      14Program
      15EXIT

        3:Prompts the user for a new directory
        4:Get the directory name from the user
        5:Parses out the Drive
        6:If Rest = '' then there was no drive specified
        8:Appends the colon on to the drive
        9:Change drives
        11:Change directory to run

                                Page [212]

        12:Prompts user for program to run
        13:Get the program name from the user
        14:Runs the program

   Example

      1 /* Sample Procedure to Change Directories */
      2 ADDRESS CMD
      3 OldPath = DosCd();
      4 OldDrive = DosDrive();
      5 SAY 'Enter the New Directory to change to?'
      6 PULL Path
      7 PARSE VALUE Path WITH Drive ':' Rest
      8 IF Rest \= '' THEN
      9    DO
      10      Drive = Drive || ':'
      11      CALL DosDrive Drive;
      12   END
      13CALL DosChDir Path;
      14SAY 'Enter the Program Name to Run?'
      15PULL Program
      16Program
      17CALL DosDrive OldDrive;
      18CALL DosChDir OldPath;
      19EXIT

        3:Saves the directory
        4:Saves the drive
        5:Prompts the user for a new directory
        6:Get the directory name from the user
        7:Parses out the drive
        8:If Rest = '' then there was no drive specified
        10:Appends the colon on to the drive
        11:Change drives
        13:Change directory
        14:Prompts the user for the program to run
        15:Gets user input
        16:Runs the program
        17:Change back to the old drive
        18:Change back to the old path

   Example

      1 /* Displays text colors available */
      2 /*   through ANSI.SYS             */
      3 ADDRESS CMD
      4 ESC = '1b'x
      5 SBegin = ESC'[0m' ESC'[34m' ESC'[40m'ESC'
      6 'ANSI ON'
      7 'cls'
      8 Say SBegin '[30m Color 30'
      9 Say SBegin '[31m Color 31'
      10Say SBegin '[32m Color 32'
      11Say SBegin '[33m Color 33'
      12Say SBegin '[34m Color 34'
      13Say SBegin '[35m Color 35'

                                Page [213]

      14Say SBegin '[36m Color 36'
      15Say SBegin '[37m Color 37'
      16Say SBegin '[40m Color 40'
      17Say SBegin '[41m Color 41'
      18Say SBegin '[42m Color 42'
      19Say SBegin '[43m Color 43'
      20Say SBegin '[44m Color 44'
      21Say SBegin '[45m Color 45'
      22Say SBegin '[46m Color 46'
      23Say SBegin '[47m Color 47'
      24Say SBegin '[37m'

        4:Sets the escape character to a variable
        6:Makes sure ansi is on
        7:Clears the screen

   Example

      1 /* Sample Procedure to add a new    */
      2 /*   directory to the PATH variable */
      3 ADDRESS CMD
      4 SAY 'New Directory to Add to The PATH Variable'
      5 PULL NewPath
      6 'SET PATH=%PATH%' || NewPath
      7 'CLS'
      8 'SET'
      9 EXIT

        4:Prompts the user for a new directory
        5:"PULL" the input from the user
        6:Sets the variable
        7:Clears the screen
        8:Displays all the variables of the environment
























                                Page [214]




                                  Index




   A

   ABBREV  85
   abbreviations
     testing for  85
   ABS  87
   absolute value
     finding  87
   abuttal concatenation operator  17
   active loop  48, 49
   addition operator  17, 184
   addition rules  185
   ADDRESS  29, 88
   alphabetics
     checking  108
   alphanumerics
     checking  108
   AND
     bit-by-bit (BITAND)  91
     logical operator  19
   ARG  31, 89
     option of PARSE instruction  55
   arguments
     of functions  31
     of programs  31
     of subroutines  31
     retrieving with ARG function  89
     retrieving with ARG instruction  31
     retrieving with PARSE ARG instruction  55
   arithmetic  183
     combination rules  185
     comparisons  187
     errors  190
     NUMERIC settings  52
     operators  184
     overflow  190
     precision  184
     underflow  190
   arithmetic operators  17
   arrays  23
     building  23
     using compound symbols as  24
   assignment  15
     of compound variables  23
     to compound variables  21




                                Page [215]

   B

   B2X  94
   binary  11
   binary strings  11
   BITAND  91
   BITOR  92
   bits  11
     checking  108
   BITXOR  93
   blank
     adjacent to special character  9
     removing with SPACE function  145
     removing with STRIP function  150
   Boolean operations  19
   bottom of program
     reaching during execution  43
   built-in functions  77
     see functions  85
   BY phrase of DO instruction  37


   C

   C2D  105
   C2X  107
   CALL  33
   CALL OFF  33
   CALL ON  33
   CENTER  95
   CENTRE( )  95
   character input
     using CHARIN  96
     using LINEIN  128
   character input and output  191
   character input stream  191
   character output
     using CHAROUT  98
     using LINEOUT  130
   character output stream  191
   character stream
     describing the state of  146
     results of operation on  146
   character streams  191, 192
   character string parsing  175
   characters
     removing with STRIP function  150
   CHARIN  96
   CHARIN( )  192
   CHAROUT  98
   CHAROUT( )  193
   CHARS  100
   CHARS( )  192
   clauses  9, 14
     as a null string  14
     as labels  14

                                Page [216]

     assignment  15
     command  15
     continuation of  13
     null  10
   clock  155
   clocks
     saving across subroutine calls  35
   closing output streams  98, 130
   CMS REXX  8
   codes
     error  202
   collating sequence
     using XRANGE  170
   colons
     as clause terminators  13
     as label terminators  14
   combination
     arithmetic rules  185
   comma
     as a continuation character  13
     in parsing  176, 182
   commands  15, 27
     trapping failures  197
   comments  9
   comparative operators  17
   COMPARE  101
   comparing
     numbers  17
     strings  17
   comparison
     using COMPARE  101
   compound symbols  23
   compound variables  23
   CONDITION  102
   condition
     option of CALL  33
   condition traps  197
     information on  200
     returning with CONDITION function  102
   conditional loops  37, 41
   conditional phrases  41
   conditions
     ERROR  33, 69, 197
     FAILURE  33, 69, 197
     HALT  33, 69, 197
     NOTREADY  33, 69, 197
     NOVALUE  69, 197
     saved during subroutine calls  35
     SYNTAX  69, 197
     trapping  33, 69
   console
     reading from with CHARIN  96
     reading from with LINEIN  128
     reading from with PARSE LINEIN  55
     reading from with PULL  61
     writing to with CHAROUT  98

                                Page [217]

     writing to with LINEOUT  130
     writing to with SAY  65
   constant symbols  22
   continuation
     character  13
     of clauses  13
   control variable  39
   controlled loops  39
   conversion
     binary to hexadecimal  94
     character to decimal  105
     character to hexadecimal  107
     decimal to character  115
     decimal to hexadecimal  117
     hexadecimal to binary  171
     hexadecimal to character  172
     hexadecimal to decimal  173
   COPIES  104
   copying a string using COPIES  104


   D

   D2C  115
   D2X  117
   data queue
     external  191
   data streams  191
   DATATYPE  108
   DATE  110
   date
     returning with DATE function  110
   date and version of REXX  57
   debugging
     using TRACE instruction  71
   decimal arithmetic  183
   default character streams  191
   delayed state  197, 198
   deleting part of a string  112
   deleting words from a string  113
   DELSTR  112
   DELWORD  113
   diagrams
     syntax  3
   DIGITS  114
     option of NUMERIC instruction  52
   division  19, 186
     operators  186
   DO  37
   DO group  37
   DROP  42
   dummy instruction  51
   dyadic operators  19




                                Page [218]

   E

   e-notation  188
   elapsed time
     saving during subroutine calls  35
   elapsed time clock  155
   END clause
     of SELECT instruction  66
     specifying control variable  40
   END clause
     of DO instruction  37
   end of stream
     testing with CHARS  100
     testing with LINES  132
   engineering notation  52, 189
   environment
     default  29
     determining current  29
     determining current using ADDRESS  88
     temporary change of  29
   equality
     testing  17
   equals operator  17
   ERROR
     condition of CALL instruction  33, 197
     condition of SIGNAL instruction  69, 197
   error
     retrieving number for  119
   error messages  202
     retrieving with ERRORTEXT  119
   error syntax  202
   errors
     during execution of functions  76
     from commands  27
     retrieving line number information  201
     trapping with CALL instruction  33, 197
     trapping with SIGNAL instruction  69, 197
   ERRORTEXT  119
   exception conditions
     saved during subroutine calls  35
   exceptions
     trapping with SIGNAL instruction  68
   exclusive OR operator  19
   exclusive OR'ing character string together  93
   EXIT  43
   exponent
     largest allowable  5
   exponential notation  188
   exponentiation  19
   EXPOSE option of PROCEDURE instruction  59
   expressions  16
     evaluation  19
     examples  20
     results of  20
     tracing results of  73
   EXTERNAL

                                Page [219]

     option of PARSE instruction  55
   external data queue  191
     counting lines in  138
     reading from with PULL  61
     writing to with PUSH  62
     writing to with QUEUE  63


   F

   FAILURE
     condition of CALL instruction  33, 197
     condition of SIGNAL instruction  69, 197
   failures
     trapping with SIGNAL instruction  68
   FIFO stacking  63
   fixing output streams  98, 130
   flow control
     abnormal with SIGNAL instruction  68
     with CALL instruction  33
   FOR phrase of DO instruction  37
   FORM  120
     option of NUMERIC instruction  52
   FORMAT  121
   formatting
     numbers for display  121
     numbers with TRUNC  160
     text centering  95
     text left justification  126
     text right justification  142
     text spacing  145
   function
     built-in
      ABBREV  85
      ABS  87
      ADDRESS  88
      ARG  89
      B2X  94
      BITAND  91
      BITOR  92
      BITXOR  93
      C2D  105
      C2X  107
      CENTER  95
      CHARIN  96, 192
      CHAROUT  98
      CHARS  100, 192
      COMPARE  101
      CONDITION  102
      COPIES  104
      D2C  115
      D2X  117
      DATATYPE  108
      DATE  110
      DELSTR  112
      DELWORD  113

                                Page [220]

      DIGITS  114
      ERRORTEXT  119
      FORM  120
      FORMAT  121
      FUZZ  123
      INSERT  124
      LASTPOS  125
      LEFT  126
      LENGTH  127
      LINEIN  128
      LINEOUT  130
      LINES  132
      MAX  133
      MIN  134
      OVERLAY  135
      POS  137
      QUEUED  138
      RANDOM  139
      REVERSE  141
      RIGHT  142
      SIGN  143
      SOURCELINE  144
      SPACE  145
      STREAM  146
      STRIP  150
      SUBSTR  151
      SUBWORD  152
      SYMBOL  153
      TIME  154
      TRACE  156
      TRANSLATE  158
      TRUNC  160
      VALUE  161
      VERIFY  163
      WORD  165
      WORDINDEX  166
      WORDLENGTH  167
      WORDPOS  168
      WORDS  169
      X2B  171
      X2C  172
      X2D  173
      XRANGE  170
   function calls  77
     syntax  77
   functions
     built-in  77
     CHAROUT  193
     external  75
     internal  75
     LINEOUT  193
     QUEUED  193
     search order  76
   FUZZ  123
     option of NUMERIC instruction  52


                                Page [221]

   H

   HALT
     condition of CALL instruction  33, 197
     condition of SIGNAL instruction  69, 197
   hexadecimal
     checking with DATATYPE  108
   hexadecimal strings  10
   host command failure  197
   host system
     issuing commands to  27


   I

   IF  44
   inclusive OR operator  19
   inequality
     testing  17
   input and output  191
   input and output error  197
   input stream  191
   INSERT  124
   inserting a string into a string  124
   Instructions
     OPTIONS  54
     PARSE  175
   instructions  14, 28
     ADDRESS  29
     ARG  31
     CALL  33
     DO  37
     DROP  42
     EXIT  43
     IF  44
     INTERPRET  46
     ITERATE  48
     keyword  14, 28
     LEAVE  49
     NOP  51
     NUMERIC  52
     PARSE  55
     PARSE LINEIN  192
     PARSE PULL  193
     PROCEDURE  59
     PULL  61
     PUSH  62, 193
     QUEUE  63, 193
     RETURN  64
     SAY  65, 193
     SELECT  66
     SIGNAL  68
     TRACE  71
   integer arithmetic  183
   internal functions  75
   INTERPRET  46

                                Page [222]

   interpretation error  198
   introduction to REXX  2
   ITERATE  48


   K

   keyword instructions  14, 28


   L

   label  14
   language date and version  57
   language definition  9
   LASTPOS  125
   leading blanks
     removing with STRIP function  150
   leading zeros
     adding with RIGHT function  142
     removing with STRIP function  150
   LEAVE  49
   LEFT  126
   LENGTH  127
   length of a string
     retrieving  127
   LIFO stacking  62
   limits
     REXX  5
   line continuation  13
   line input and output  191
   LINEIN  128
     option of PARSE instruction  55
     role in input and output  192
   LINEOUT  130
   LINEOUT( )  193
     role in input and output  193
   LINES  132
     role in input and output  192
   lines from program
     retrieving with SOURCELINE  144
   literal patterns  176
   literal strings  10
   locating a string in another string  125, 137
   locating a word or phrase in a string  168
   logical operations  19
   loops
     active  48
     modification of  48
     status of  35
     termination of  49






                                Page [223]

   M

   mantissa of exponential numbers  189
   math  183
   MAX  133
   maximum number
     retrieving  133
   memory  5
   messages
     error  202
   MIN  134
   minimum number
     retrieving  134
   monadic (prefix) operators  19
   multiple strings
     parsing  182
   multiplication  19


   N

   names
     of compound symbols  23
     of variables  21
   NOP  51
   normal comparative operators  17
   NOT operator  18
   notation
     engineering  52, 189
     exponential  188
     scientific  189
   NOTREADY
     condition of CALL instruction  33, 197
     condition of SIGNAL instruction  69, 197
   NOVALUE
     condition of CALL instruction  197
     condition of SIGNAL instruction  69, 197
   null clauses  14
   null instruction
     NOP  51
   numbers  11, 183
     arithmetic on  17
     checking with DATATYPE  108
     comparing  17
     formatting for display  121
     retrieving largest  133
     retrieving smallest  134
     truncating  160
     use of by REXX  190
   NUMERIC  52
     DIGITS  52
     FORM  52
     FUZZ  52
   NUMERIC DIGITS setting
     returning with DIGITS function  114
   NUMERIC FORM setting

                                Page [224]

     retrieving with FORM function  120
   NUMERIC FUZZ setting
     retrieving with FUZZ function  123
   numeric patterns
     parsing  179


   O

   OFF
     option of CALL instruction  33
     option of SIGNAL instruction  68
   ON
     option of CALL instruction  33
     option of SIGNAL instruction  68
   operators  12, 16
     arithmetic  17
     comparative  17
     logical  19
   OPTIONS  54
   OR
     bit-by-bit  92
   OR'ing character strings together  92
   OTHERWISE clause
     of SELECT instruction  66
   output and input  191
   output stream  191
   overflow
     arithmetic  190
   OVERLAY  135
   overlaying a string onto another  135


   P

   p-code  5
   packing a string with X2C  172
   parentheses
     in expressions  16, 19
   PARSE  55
   PARSE ARG  55
   PARSE EXTERNAL  55
   PARSE LINEIN  55, 192
   PARSE LINEIN role in input and output  192
   PARSE PULL  55, 193
     role in input and output  193
   PARSE SOURCE  55
   PARSE VALUE  55
   PARSE VAR  55
   PARSE VERSION  55
   parsing  175
     character strings  175
     numeric patterns  179
     patterns  176
     positional patterns  180
     selecting words  175

                                Page [225]

     variable patterns  178
   parsing template
     in PULL instruction  61
   parsing templates  175
     in PARSE instruction  55
   patterns
     in parsing  175
   period
     as placeholder in parsing  179
   placeholder
     using in a template  179
   POS  137
   positional patterns  180
   power operator
     definition  186
   powers of ten in numbers  189
   precedence of operators  19
   prefix operators  19
   priority of operators  19
   PROCEDURE  59
   program
     retrieving lines with SOURCELINE  144
   program errors
     trapping with CALL instruction  197
     trapping with SIGNAL instruction  197
   program size limit  5
   programs
     retrieving name of  56
   pseudo-code  5
   pseudorandom number function
     RANDOM  139
   PULL  61, 193
     option of PARSE instruction  55
   pure numbers  188
   PUSH  62, 193


   Q

   quasi-random number function
     RANDOM  139
   QUEUE  63, 193
   queue
     counting lines in  138, 193
     creating  193
     deleting current  193
     querying current  193
     reading  128
     reading from  191, 193
     reading from with PULL  61
     setting current  193
     writing  130
     writing to  193
     writing to with PUSH  62
     writing to with QUEUE  63
   QUEUED  138

                                Page [226]

   QUEUED( )  193


   R

   RANDOM  139
   RC
     set by commands  27
   remainder  17
   reordering data
     with TRANSLATE function  158
   repeating a string using COPIES  104
   resetting input streams  96, 128
   resetting output streams  98, 130
   residual count
     returned by CHAROUT  98
     returned by LINEOUT  130
   results
     length of  20
   RETURN  64
   return code
     set by commands  27
   REVERSE  141
   reversing a string  141
   REXX
     background  2
     differences from CMS REXX  8
     introduction to  2
     limits  5
   RIGHT  142
   rounding  184
   routines
     calling  33
   running off the end of a program  43


   S

   SAY  65, 193
     role in input and output  193
   scientific notation  52, 189
   search order
     for functions  76
     for subroutines  33
   searching a string for a word or phrase  168
   seed
     for RANDOM function  139
   SELECT  66
   semicolons  13
   SIGN  143
   SIGNAL  68
   significant digits in arithmetic  184
   simple DO group  38
   simple symbols  22
   size limits  5
   SOURCE

                                Page [227]

     option of PARSE instruction  55
   SOURCELINE  144
   SPACE  145
   special characters  12
   stem of a variable  23
     assignment  23
   stepping through programs  71
   STREAM  146
   string
     reversing  141
   string parsing  175
   strings
     binary  11
     comparing  17
     hexadecimal  10
     length of  20
     literal  10
     null  20
   STRIP  150
   subexpressions  16
   subroutines
     calling  33
     calling built-in or external  33
   substitution in variable names  22, 23
   SUBSTR  151
   subtraction  17
   SUBWORD  152
   SYMBOL  153
   symbols  11, 21
     assigning values to  21
     compound  23
     constant  22
     retrieving value with VALUE function  161
     simple  22
     testing for previous use  153
   SYNTAX
     condition of SIGNAL instruction  69
   syntax checking with TRACE instruction  71
   SYNTAX condition of SIGNAL instruction  198
   syntax diagrams  3
   system
     issuing commands to  27


   T

   tail of a variable  23
     assignment  24
   templates
     in PARSE instruction  55
     in PULL instruction  61
     parsing  175
   terminal
     reading from with PULL  61
     writing to with SAY  65
   terms  16

                                Page [228]

   THEN
     following IF clause  44
   TIME  154
   time-of-day
     retrieving with TIME function  154
   TO phrase of DO instruction  37
   tokens  9
   TRACE  71, 156
   trace setting
     altering with TRACE function  156
     changing with TRACE instruction  71
     querying  156
     saving during subroutine calls  35
   tracing
     execution of programs  71
     interactive  71
     retrieving trace setting  156
   trailing blanks
     removing with STRIP  150
   trailing zeros
     in arithmetic  184
     removing with STRIP  150
   TRANSLATE  158
   translation
     with TRANSLATE function  158
   trapname option
     of CALL instruction  198
     of SIGNAL instruction  198
   trapped conditions
     returning with CONDITION function  102
   true value  17
   TRUNC  160
   truncating numbers  160
   type of data
     checking with DATATYPE  108
   type-ahead lines
     counting characters with CHARS  100
     counting with LINES  132
   typeless strings  20


   U

   underflow
     arithmetic  190
   uninitialized variables
     value of  22
   unpacking a string with C2X  107
   UNTIL phrase of DO instruction  38
   upper case translation
     during ARG instruction  55
     during PULL instruction  61
   UPPER in PARSE instruction  55
   uppercase translation
     with TRANSLATE function  158
   user input and output  191

                                Page [229]

   V

   VALUE  161
     option of ADDRESS instruction  29
     option of PARSE instruction  55
     option of SIGNAL instruction  68
     option of TRACE instruction  71
   VAR
     option of PARSE instruction  55
   variable
     largest allowable  5
   variable patterns  178
   variables  21
     assigning values to  21, 25
     compound  23
     initial value  22
     names of  21
     retrieving value with VALUE function  161
     simple  22
     substitution in names  22
     testing for initialization  153
   VERIFY  163
   VERSION
     option of PARSE instruction  55


   W

   WHEN clause
     of SELECT instruction  66
   WHILE phrase of DO instruction  38
   whole numbers
     checking with DATATYPE  108
   WORD  165
   WORDINDEX  166
   WORDLENGTH  167
   WORDPOS  168
   WORDS  169
   words
     counting in a string  169
     deleting from a string  113
     extracting from a string  152, 165
     finding in a string  168
     finding length of  167
     locating in a string  165


   X

   X2B  171
   X2C  172
   X2D  173
   XOR
     bit-by-bit  93
   XOR'ing character strings together  93
   XRANGE  170

                                Page [230]

   Z

   zeros
     adding on the left  142
     removing with STRIP function  150




















































                                Page [231]


























































                                Page [232]

